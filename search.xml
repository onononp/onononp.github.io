<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中的IO流体系</title>
      <link href="2021/03/23/Java%E4%B8%AD%E7%9A%84IO%E6%B5%81%E4%BD%93%E7%B3%BB/"/>
      <url>2021/03/23/Java%E4%B8%AD%E7%9A%84IO%E6%B5%81%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-lazy-src="IO%E6%B5%81%E4%BD%93%E7%B3%BB.png" alt="IO流体系"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> IO流体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
            <tag> BIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/17/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>2021/03/17/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="class字节码文件结构"><a href="#class字节码文件结构" class="headerlink" title="class字节码文件结构"></a>class字节码文件结构</h2><table><thead><tr><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>魔数,识别Class文件格式</td><td>4个字节</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>接口计数器</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td><td>attributes_count</td></tr></tbody></table><h2 id="Class文件版本号和平台的对应"><a href="#Class文件版本号和平台的对应" class="headerlink" title="Class文件版本号和平台的对应"></a>Class文件版本号和平台的对应</h2><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><h2 id="class文件数据类型"><a href="#class文件数据类型" class="headerlink" title="class文件数据类型"></a>class文件数据类型</h2><table><thead><tr><th>数据类型</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>无符号数</td><td>无符号数可以用来描述数字、索引引用、数量值或按照utf-8编码构成的字符串值。</td><td>其中无符号数属于基本的数据类型。 以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节</td></tr><tr><td>表</td><td>表是由多个无符号数或其他表构成的复合数据结构。</td><td>所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td></tr></tbody></table><h2 id="类型描述符"><a href="#类型描述符" class="headerlink" title="类型描述符"></a>类型描述符</h2><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td>[</td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td></tr></tbody></table><h2 id="常量类型和结构"><a href="#常量类型和结构" class="headerlink" title="常量类型和结构"></a>常量类型和结构</h2><table><thead><tr><th>类型</th><th>标志(或标识)</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><h2 id="常量类型和结构细节"><a href="#常量类型和结构细节" class="headerlink" title="常量类型和结构细节"></a>常量类型和结构细节</h2><p><img src= "/img/loading.gif" data-lazy-src="assets/1598773300484.png" alt="1598773300484"></p><p><img src= "/img/loading.gif" data-lazy-src="assets/1598773308492.png" alt="1598773308492"></p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><h2 id="字段表访问标志"><a href="#字段表访问标志" class="headerlink" title="字段表访问标志"></a>字段表访问标志</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><table><thead><tr><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>this_class</td></tr><tr><td>u2</td><td>super_class</td></tr><tr><td>u2</td><td>interfaces_count</td></tr><tr><td>u2</td><td>interfaces[interfaces_count]</td></tr></tbody></table><h2 id="属性的通用格式"><a href="#属性的通用格式" class="headerlink" title="属性的通用格式"></a>属性的通用格式</h2><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td><td>属性表</td></tr></tbody></table><h2 id="数据类型和默认初始值对应"><a href="#数据类型和默认初始值对应" class="headerlink" title="数据类型和默认初始值对应"></a>数据类型和默认初始值对应</h2><table><thead><tr><th>类型</th><th>默认初始值</th></tr></thead><tbody><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>char</td><td>\u0000</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/17/%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8E%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/"/>
      <url>2021/03/17/%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8E%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="安装包与安装路径"><a href="#安装包与安装路径" class="headerlink" title="安装包与安装路径"></a>安装包与安装路径</h1><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>不管是在手机上，还是电脑上，如果想要安装程序，都需要安装包。安装包的意思就是通过这个东西可以安装程序。<br>我们平常用的都是<code>windows</code>系统的电脑，常见（大部分，大约$99.9%$的日常生活中会遇到的)安装包的后缀名都是<code>.exe</code>。极少数情况下，后缀名会是<code>.msi</code>。</p><p><strong>但是，后缀名是<code>.exe</code>的不一定是安装包。</strong></p><p>安装包的作用仅限于让我们安装上程序，所以在安装完成之后就可以删除掉这个安装包文件。</p><h2 id="安装路径"><a href="#安装路径" class="headerlink" title="安装路径"></a>安装路径</h2><p>在安装程序的时候，会让我们选择程序的安装路径，也就是说<strong>程序的安装位置</strong>。因为现在的电脑不缺那点</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/17/okhttp%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/03/17/okhttp%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="okhttp学习"><a href="#okhttp学习" class="headerlink" title="okhttp学习"></a>okhttp学习</h1><ul><li><code>okhttp</code>请求流程</li><li>高并发请求分发器与线程池</li><li>责任链模式请求与响应式拦截器</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/17/Java%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1/"/>
      <url>2021/03/17/Java%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="Java中的自动拆箱和自动装箱："><a href="#Java中的自动拆箱和自动装箱：" class="headerlink" title="Java中的自动拆箱和自动装箱："></a>Java中的自动拆箱和自动装箱：</h2><p><code>Java</code>中的每个基本数据类型都对应一个包装类型：</p><p>基本数据类型提升为对应的包装类型 称为自动装箱。</p><p>总结：</p><ul><li><code>=</code>:装箱或拆箱</li><li>比较运算：拆箱</li><li>四则运算：拆箱</li><li><code>equals</code>进行比较：装箱</li><li>集合框架：装箱</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/03/16/hello-world/"/>
      <url>2021/03/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="2021/03/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/03/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><p>进程是资源分配和调度的基本单位。</p><p>线程是调度的基本单位。一个进程可以包含多个线程。线程之间共享进程的堆和方法区。可以有自己的程序计数器，虚拟机栈等。</p><h3 id="Thread类中start-方法和run-方法的区别"><a href="#Thread类中start-方法和run-方法的区别" class="headerlink" title="Thread类中start()方法和run()方法的区别"></a><code>Thread</code>类中<code>start()</code>方法和<code>run()</code>方法的区别</h3><p><code>start()</code>方法会调用<code>run()</code>方法，会开启一个新的线程。</p><p>而<code>run()</code>方法并不会开启一个新的线程</p><p>**start()**方法会有一个对状态的验证：</p><p><img src= "/img/loading.gif" data-lazy-src="start%E6%96%B9%E6%B3%95%E5%AF%B9%E7%8A%B6%E6%80%81%E7%9A%84%E9%AA%8C%E8%AF%81.png" alt="start方法对状态的验证"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Comparable和Comparator</title>
      <link href="2021/03/09/Comparable%E5%92%8CComparator/"/>
      <url>2021/03/09/Comparable%E5%92%8CComparator/</url>
      
        <content type="html"><![CDATA[<h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a><code>Comparable</code>接口</h2><p>这个接口位于<code>java.lang</code>包下，只有一个方法：<code>compareTo(Object o)</code>。<strong>在JDk1.5后，加入了泛型类型。</strong></p><p>可以用来排序用户自定义类</p><h2 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a><code>Comparator</code>接口</h2><p>这个接口位于<code>java.util</code>包下，含有许多方法，其中有：<code>compare(Object o1,Object o2)</code>。也是用来排序用户自定义类的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="2021/03/04/Java%E9%9B%86%E5%90%88/"/>
      <url>2021/03/04/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="Java整体的集合框架"><a href="#Java整体的集合框架" class="headerlink" title="Java整体的集合框架"></a><code>Java</code>整体的集合框架</h2><p><img src= "/img/loading.gif" data-lazy-src="java-collection-hierarchy.png" alt="java-collection-hierarchy"></p><p><img src= "/img/loading.gif" data-lazy-src="arraylist.png" alt="arraylist.png"></p><p><img src= "/img/loading.gif" data-lazy-src="linkedlist.png" alt="linkedlist.png"></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a><code>List</code></h3><h4 id="排序List的方法"><a href="#排序List的方法" class="headerlink" title="排序List的方法"></a>排序<code>List</code>的方法</h4><ol><li>可以使用<code>Collections.sort()</code>方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android学习笔记</title>
      <link href="2021/03/03/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/03/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="区别DVM和JVM"><a href="#区别DVM和JVM" class="headerlink" title="区别DVM和JVM"></a>区别<code>DVM</code>和<code>JVM</code></h3><ol><li>首要区别<ol><li><code>Dalvik</code>:基于寄存器，编译和运行都会更快些</li><li><code>JVM</code>:基于栈，编译和运行都会慢些</li></ol></li><li>字节码的区别<ol><li><code>Dalvik</code>:执行<code>.dex</code>格式的字节码，是对<code>.class</code>文件进行压缩后产生的，文件变小</li><li><code>JVM</code>:执行<code>.class</code>格式的字节码</li></ol></li><li>运行环境的区别<ol><li><code>Dalvik</code>:一个应用启动都运行一个单独的虚拟机，运行在一个单独的进程中</li><li><code>JVM</code>:只能运行一个实例，也就是所有应用都运行在同一个<code>JVM</code>中</li></ol></li></ol><h3 id="Android系统文件目录结构"><a href="#Android系统文件目录结构" class="headerlink" title="Android系统文件目录结构"></a><code>Android</code>系统文件目录结构</h3><ul><li><p><code>/</code></p><p>代表系统的根目录</p></li><li><p><code>/data/app/</code></p><p>存放着第三方的<code>apk</code>文件</p></li><li><p><code>/system/app/</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 学习笔记 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能监控与调优</title>
      <link href="2021/03/03/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/"/>
      <url>2021/03/03/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 调优 </tag>
            
            <tag> 性能监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库学习</title>
      <link href="2021/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h2><ol><li><code>net start mysql</code></li><li><code>net stop mysql</code></li></ol><hr><h2 id="查看当前mysql的版本"><a href="#查看当前mysql的版本" class="headerlink" title="查看当前mysql的版本"></a>查看当前<code>mysql</code>的版本</h2><ol><li><code>select version()</code></li><li><code>mysql --version</code></li></ol><hr><h2 id="零星知识"><a href="#零星知识" class="headerlink" title="零星知识"></a>零星知识</h2><ul><li>注释：<ul><li>单行注释：#注释文字</li><li>单行注释：– 注释文字</li><li>多行注释：/* 注释文字 */</li></ul></li><li><code>ifnull</code>: <code>ifnull(null,200)</code></li><li><code>isnull</code>:如果是空，返回1；否则返回0；</li><li><code>escape</code>关键字</li></ul><hr><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ol><li>简单条件运算符：<code>&gt;,&lt;,=,!=,&lt;&gt;,&gt;=,&lt;=</code></li><li>逻辑运算符：<code>&amp;&amp; || ! and or not</code></li><li>模糊查询：<code>like, between and,in ,is null</code><ol><li><code>between and </code>：包含两个端点。两个临界值不能颠倒。</li><li><code>in</code>: 列表中的值类型必须统一或兼容。列表中不可以使用通配符。</li><li> <code>is null 与 is not null</code>: <code>&lt;&gt; 或 !=</code>不能判断<code>null</code>值。</li><li>安全等于<code>&lt;=&gt;</code>：可以判断普通值和<code>null</code>值。<em>但可读性较差。</em></li></ol></li><li>排序查询</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java去永久代</title>
      <link href="2020/12/15/java%E5%8E%BB%E6%B0%B8%E4%B9%85%E4%BB%A3/"/>
      <url>2020/12/15/java%E5%8E%BB%E6%B0%B8%E4%B9%85%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<p>翻译自：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从<code>HotSpot</code>虚拟机中去除永久代，调整永久代的大小。</p><h2 id="Non-Goals"><a href="#Non-Goals" class="headerlink" title="Non-Goals"></a><code>Non-Goals</code></h2><p> 扩展应用类之间的类信息分享。减少类元信息需要的内存。保证类元数据的异步收集。</p><h2 id="成功量度"><a href="#成功量度" class="headerlink" title="成功量度"></a>成功量度</h2><p>类元信息，字符串字面量和静态变量将会从永久代中转移到Java堆中或者本地内存中。</p><p>HotSpot虚拟机中的永久代将会被去除。</p><p>类的启动和空间不会回退1%。？？？</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>JRockit虚拟机中没有永久代的概念。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>将HotSpot虚拟机中的部分内容转移到堆中，剩余的部分放到直接内存中。</p><p>现在Java的类信息存放在Java堆中的永久代中。另外，字符串字面量和类的静态变量也存放在永久代。永久代是被HotSpot虚拟机管理的，必须有充足的空间存放应用程序需要的类元信息、字符串字面量和类的静态变量。类元信息和静态变量在类加载的时候被分配在永久代中，当类卸载的时候被垃圾回收。字符串字面量在永久代GC的时候也会被回收。</p><p>推荐的实现交付把类元信息存放在直接内存中，将字符串字面量和类的静态变量放在Java堆中。HotSpot虚拟机显式地申请和释放类元信息的本地内存。新的类元信息的分配将会受制于可用的本地内存的大小，而不是最大的永久代的大小。</p><p>类元信息本地内存的分配以块为单位，足够大存放下类元信息。每个块都有一个类加载器，类加载器加载的类元信息将会从加载器的块上分配。额外的块可以分配给类加载器当需要的时候。块大小根据应用程序的行为变化。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 永久代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一个好看的typora主题</title>
      <link href="2020/12/10/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9C%8B%E7%9A%84typora%E4%B8%BB%E9%A2%98/"/>
      <url>2020/12/10/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9C%8B%E7%9A%84typora%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>分享一个好看的<code>typora</code>主题：<br><img src= "/img/loading.gif" data-lazy-src="%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="主题截图"><br>主题链接：<a href="https://github.com/TriDiamond/typora-theme-obsidian">https://github.com/TriDiamond/typora-theme-obsidian</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> typora </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android三级缓存</title>
      <link href="2020/12/07/Android%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
      <url>2020/12/07/Android%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Android三级缓存"><a href="#Android三级缓存" class="headerlink" title="Android三级缓存"></a>Android三级缓存</h1><ol><li>缓存机制加载流程</li><li><code>LRU</code>算法：当元素个数超过允许的数量的时候，去除最近最少使用的元素。<ul><li><code>android.util</code>包下，对<code>LinkedHashMap</code>的封装，<code>true</code>:访问排序</li></ul></li><li>活动/内存的由来 内存缓存 活动缓存 高频问题 <code>glide</code>源码</li><li>资源封装/活动内存/内存缓存/磁盘缓存</li><li>生命周期/<code>manager</code>/<code>load_data</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 三级缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 三级缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>endnote学习笔记</title>
      <link href="2020/12/07/endnote%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/12/07/endnote%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="endnote学习笔记"><a href="#endnote学习笔记" class="headerlink" title="endnote学习笔记"></a>endnote学习笔记</h1><p>文献管理软件</p>]]></content>
      
      
      <categories>
          
          <category> endnote学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> endnote学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git忽略文件</title>
      <link href="2020/12/07/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/"/>
      <url>2020/12/07/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<ul><li>在工程中，并不是所有文件都需要保存到版本库中的，例如<code>target</code>目录及目录下的文件就可以忽略。在<code>Git</code>工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，<code>Git</code>就会自动忽略这些文件或目录。</li></ul><h2 id="Git忽略规则优先级"><a href="#Git忽略规则优先级" class="headerlink" title="Git忽略规则优先级"></a><code>Git</code>忽略规则优先级</h2><p>在<code>.gitignore</code>文件中，每一行指定一个忽略规则，<code>Git</code>检查忽略规则的时候有多个来源，它的优先级如下(由高到低)：</p><blockquote><p>从命令行中读取可用的忽略规则</p><p>当前目录定义的规则</p><p>父级目录定义的规则，依次递推</p><p>%Git_DIR​%/info/exclude文件中定义的规则</p><p>core.excludesfile中定义的全局规则</p></blockquote><h2 id="Git忽略规则匹配语法"><a href="#Git忽略规则匹配语法" class="headerlink" title="Git忽略规则匹配语法"></a><code>Git</code>忽略规则匹配语法</h2><blockquote><p>空格不匹配任意文件，可作为分隔符，可用反斜杠转义</p><p>开关的文件标识注释，可以使用把斜杠进行转义</p><p>！开头的模式标识否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用！也不会被再次包含。可以使用反斜杠进行转义</p><p>/结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件</p><p>/开始的模式匹配项目跟目录</p><p>.gitignore文件中，则相对于项目根目录</p><p>**用于匹配多级目录，可在开始，中间，结束</p><p>？匹配单个字符</p><p>*通用匹配零个或多个字符</p></blockquote><h3 id="常用匹配示例"><a href="#常用匹配示例" class="headerlink" title="常用匹配示例"></a>常用匹配示例</h3><blockquote><p>bin/:忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略bin文件</p><p>/bin:忽略根目录下的bin文件</p><p>/*.c:忽略cat.c，不忽略build/cat.c</p><p>*.log:忽略所有.log文件</p><p>debug/*.obj:忽略debug/io.obj，不忽略debug/common/io.obj和tools/debug/io.obj</p><p>**/foo:忽略/foo，a/foo，a/b/foo等</p><p>!/bin/run.sh不忽略bin目录下的run.sh文件</p><p>config.php:忽略当前路径的config.php文件</p></blockquote><h3 id="gitignore规则不生效"><a href="#gitignore规则不生效" class="headerlink" title=".gitignore规则不生效"></a><code>.gitignore</code>规则不生效</h3><p><code>.gitignore</code>只能忽略那些原来没有被<code>track</code>的文件，如果某些文件已经被纳入了版本管理中，则修改<code>.gitignore</code>是无效的</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>先把本地缓存删除（改变成未<code>track</code>状态），然后再提交</p><blockquote><p>git rm -r –cached .</p><p>git add .</p><p>git commit -m ‘update .gitignore’</p></blockquote><p>如果非要添加某个已经被忽略规则忽略的文件，可以使用<code>-f</code>强制添加到<code>Git</code>:</p><blockquote><p>git add -f App.class</p></blockquote><p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底是哪个规则写错了，可以用<code>git checkignote</code>命令检查：</p><blockquote><p>git check-ignore -v App.class</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络总结</title>
      <link href="2020/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
      <url>2020/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ul><li><p>应用层：所有能和用户交互产生流量的程序 FTP SMTP HTTP</p></li><li><p>表示层：用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p><ul><li><p>功能一：数据格式变换 （翻译官）</p></li><li><p>功能二：数据加密解密</p></li><li><p>功能三：数据压缩和恢复</p><p>jpeg、ASCII协议</p></li></ul></li><li><p>会话层：向表示层实体/用户进程提供建立连接并在连接上有序的传输数据，这是会话，也是建立同步(SYN) </p><ul><li><p>建立、管理、终止会话</p></li><li><p>使用校验点可使会话在通信失效时从校验点/同步 点继续恢复通信，实现数据同步</p><p>ADSP、ASP</p></li></ul></li><li><p>传输层：负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报</p><ul><li><p>可靠传输、不可靠传输</p></li><li><p>差错控制</p></li><li><p>流量控制</p></li><li><p>复用分用</p><p>TCP、UDP</p></li></ul></li><li><p>网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供服务。网络层传输单位是数据报。</p><ul><li><p>路由选择</p></li><li><p>流量控制</p></li><li><p>差错控制</p></li><li><p>拥塞控制</p><p>IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p></li></ul></li><li><p>数据链路层：把网络层传下来的数据报组装成帧。数据链路层的传输单位是帧。</p><ul><li><p>成帧（定义帧的开始和结束）</p></li><li><p>差错控制 帧错+位错</p></li><li><p>流量控制</p></li><li><p>访问（接入）控制 控制对信道的访问</p><p>SDLC、HDLC、PPP、STP</p></li></ul></li><li><p>物理层：在物理媒体上实现比特流的透明传输。物理层出书单位是比特。</p><ul><li>定义接口特性</li><li>定义传输模式 单工、半双工、双工</li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li><li>Rj45、802.3</li></ul></li></ul><hr><ol><li>编码</li></ol><ul><li>数字数据编码为数字信号：（数字发送器）<ul><li>非归零编码<ul><li>1表示高电平，0表示低电平</li></ul></li><li>归零编码<ul><li>在每个时钟周期内，都是以0结束</li></ul></li><li>反向不归零编码<ul><li>信号电平翻转表示0，不翻转表示1</li></ul></li><li>曼彻斯特编码</li><li>差分曼彻斯特编码<ul><li>同1异0</li></ul></li><li>4B/5B编码<ul><li>比特流中插入额外的比特以打破一连串的0或1，用5个比特来编码4个比特的数据</li><li>编码效率是80%</li></ul></li></ul></li><li>数字数据编码为模拟信号：（调制器）</li><li><h2 id="模拟数据编码为数字信号"><a href="#模拟数据编码为数字信号" class="headerlink" title="模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h2></li><li></li></ul><hr><ol><li>无连接服务：不事先为分组的传输确立传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</li><li>连接服务：首先为分组的传输确定传输路径（建立连接），然后沿该路径（连接）传输系列分组，系列分组传输路径相同，传输结束后拆除连接。</li></ol><hr><ul><li>数据链路层<ul><li>组帧<ol><li>字符计数法：容易出错 不常用</li><li>字符填充法：填充转义字符</li><li>零比特填充法：发送端：连续5个1就插入1个0 接收端：逆过程</li><li>违规编码法</li></ol></li><li>检错编码：海明码 ：发现双比特错 纠正单比特错</li></ul></li><li>可靠传输： 发送端发啥 接收端接收啥</li><li>流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧</li><li>滑动窗口协议：<ul><li>流量控制：收不下不给确认，想发也发不了</li><li>可靠传输：发送方自动重传</li></ul></li></ul><p>111</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习</title>
      <link href="2020/12/07/JVM%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/12/07/JVM%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>在加载阶段，Java虚拟机主要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的进行时数据结构</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口<span id="more"></span></li></ol><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>加载-&gt;链接-&gt;初始化</p><p>链接：验证-&gt;准备-&gt;解析</p><ol><li>验证：进行字节码文件的各种验证，比如：<strong>文件格式验证</strong>（是否以魔数<code>0xCAFEBABE</code>开头）等，<strong>元数据验证</strong>（这个类是否有父类，是否继承了不允许被继承的类）等，<strong>字节码验证</strong>（对类的方法体进行验证，保证类的方法在运行时不会做出危害虚拟机安全的行为），<strong>符号引用验证</strong>（该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源）</li><li>准备：为类变量定义初始值（<strong>被<code>final</code>修饰的常量会直接赋程序员定义的值，而不是默认值</strong>）</li><li>解析：将符号引用替换为直接引用</li></ol><p>初始化：就是执行类构造器<code>&lt;clinit&gt;</code>方法的过程。<code>clinit</code>方法是编译器自动收集类中所有的类变量的赋值动作和静态代码块中的语句合并而成的。**<code>&lt;clinit&gt;</code>方法会被自动的加锁同步**</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>从<code>jdk 1.2</code>开始，类的加载使用双亲委派机制。</p><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p><code>JVM</code>中有三个重要的<code>ClassLoader</code>，除了<code>BoottsrapClassLoader</code>外，其它类加载器均由<code>Java</code>实现，并且全部继承自<code>java.lang.ClassLoader</code>:</p><ol><li><code>BootstrapClassLoader(启动类加载器)</code>：最顶层的加载类，由<code>C++</code>实现，负责加载<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数指定的路径中的所有类</li><li><code>ExtensionClassLoader(扩展类加载器)</code>：该类是在类<code>sun.misc.Launcher&amp;ExtClassLoader</code>中以<code>Java</code>代码形式实现的。负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。</li><li><code>AppClassLoader(应用程序类加载器)</code>：也叫<code>系统类加载器</code>。面向我们的用户的加载器，负责加载用户类路径上所有的类库。</li></ol><h3 id="关于数组类的加载器"><a href="#关于数组类的加载器" class="headerlink" title="关于数组类的加载器"></a>关于数组类的加载器</h3><p><strong>数组类的<code>Class</code>对象，不是由类加载器去创建的，而是在<code>Java</code>运行期<code>JVM</code>根据需要自动创建的。对于数组类的类加载器来说，是通过<code>Class.getClassLoader()</code>返回的，与数组当中的元素类型的类加载器是一样的；如果当前数组元素类型是基本数据类型，数组类是没有类加载器的。</strong></p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>在类加载的时候，系统会先判断当前类是否被加载过。已经被加载过的类会直接返回，否则才会尝试加载。加载的时候，首先会将该请求委派给父类加载器的<code>loadClass()</code>处理，因此所有的请求最终都会传送到顶层的启动类加载器<code>BootstrapClassLoader</code>中。当父类加载器无法处理时，都由自己来处理。当父类加载器为<code>null</code>时，会使用启动类加载器<code>BootstrapClassLoader</code>作为父类加载器。</p><p><strong>类的双亲委派模型是用 组合 实现的，而不是继承实现的。双亲并不意味着有一个父亲，一个母亲。</strong></p><h3 id="双亲委派模型的好处："><a href="#双亲委派模型的好处：" class="headerlink" title="双亲委派模型的好处："></a>双亲委派模型的好处：</h3><ol><li>避免类的重复加载，父类加载器已经加载一次之后，子类加载器没有必要再加载一次</li><li>避免核心<code>API</code>被修改<ol><li>自定义类：<code>java.lang.String</code></li><li>自定义类：<code>java.lang.A</code></li></ol></li></ol><p><code>loadClass()</code>的源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">           <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">           Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                   <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                   <span class="comment">// to find the class.</span></span><br><span class="line">                   <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                   c = findClass(name);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> c;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="获取类加载器的几种方式"><a href="#获取类加载器的几种方式" class="headerlink" title="获取类加载器的几种方式"></a>获取类加载器的几种方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、通过Class对象的getClassLoader()方法</span></span><br><span class="line">      ClassLoader classLoader = A.class.getClassLoader();</span><br><span class="line">      System.out.println(classLoader);</span><br><span class="line">      <span class="comment">//2、获取当前线程上下文的ClassLoader</span></span><br><span class="line">      ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">      System.out.println(contextClassLoader);</span><br><span class="line">      <span class="comment">//3、获取系统的ClassLoadeer</span></span><br><span class="line">      ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">      System.out.println(systemClassLoader);</span><br></pre></td></tr></table></figure><h3 id="类加载器类中的方法"><a href="#类加载器类中的方法" class="headerlink" title="类加载器类中的方法"></a>类加载器类中的方法</h3><h4 id="抽象类ClassLoader内部的主要方法（内部没有抽象方法）："><a href="#抽象类ClassLoader内部的主要方法（内部没有抽象方法）：" class="headerlink" title="抽象类ClassLoader内部的主要方法（内部没有抽象方法）："></a>抽象类<code>ClassLoader</code>内部的主要方法（内部没有抽象方法）：</h4><ol><li>public final ClassLoader getParent()<ul><li>返回该类的超类加载器</li></ul></li><li>public Class&lt;?&gt; loadClass(String name ) throws ClassNotFoundException<ul><li>加载名称为name的类，返回结果为<code>java.lang.Class</code>类的实例。如果找不到类，则返回<code>ClassNotFoundException</code>异常。该方法中的逻辑就是双亲委派机制的实现。</li></ul></li><li>public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException()<ul><li>查找二进制名称为<code>name</code>的类，返回结果为<code>java.lang.Class</code>的实例。这是一个受保护的方法，<code>JVM</code>鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被<code>loadClass</code>方法调用。</li></ul></li><li>protected final Class&lt;?&gt; defineClass(String name,byte[] b,int off,int len)<ul><li>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是<code>ClassLoader</code>从外部获得的。这是受保护的方法，只有在自定义<code>ClassLoader</code>子类中可以使用。</li></ul></li></ol><h3 id="破坏双亲委派机制的行为"><a href="#破坏双亲委派机制的行为" class="headerlink" title="破坏双亲委派机制的行为"></a>破坏双亲委派机制的行为</h3><ol><li><code>JDK1.2</code>之前的“远古”时代，不满足双亲委派模型</li><li>这个模型自身的缺陷导致的</li><li>用户对程序动态性的追求而导致的。如：代码热替换、模块热部署等</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及<code>Java</code>类型转换，则加载器反而容易产生不美好的事情。在做<code>Java</code>类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则，转换时会发生异常。</p><h2 id="JDK-9的新特性"><a href="#JDK-9的新特性" class="headerlink" title="JDK 9的新特性"></a><code>JDK 9</code>的新特性</h2><p>主要发生了五个变化</p><ol><li><p>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（<code>platform classloader</code>）。可以通过<code>ClassLoader</code>的新方法<code>getPlatfromClassLoader()</code>来获取。</p></li><li><p>平台类加载器和应用程序类加载器都不再继承于<code>java.net.URLClassLoader</code>。现在启动类加载器、平台类加载器、应用程序类加载器全部继承于<code>jdk.internal/loader/BuiltinClassLoader</code></p></li><li><p>在Java 9 中，类加载器有了名称。该名称在构造方法中指定，可能通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</p></li><li><p>启动类加载器现在是在JVM内部和Java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null,而不会得到BootClassLoader</p></li><li><p>类加载的委派关系也发生了变化。</p></li></ol><hr><h2 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h2><p><img src= "/img/loading.gif" data-lazy-src="%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="运行时数据区"></p><p>线程私有的：程序计数器、本地方法栈、虚拟机栈</p><p>线程共享的：堆、方法区</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>没有<code>GC</code>。 没有<code>OOM</code></p><h3 id="虚拟机栈（Java栈）"><a href="#虚拟机栈（Java栈）" class="headerlink" title="虚拟机栈（Java栈）"></a>虚拟机栈（<code>Java</code>栈）</h3><p>栈管运行，堆管存储</p><p>没有<code>GC</code></p><p>以栈帧存储。</p><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><ol><li>局部变量表<code>(Local Variables)</code></li><li>操作数栈</li><li>动态链接</li><li>方法返回地址</li><li>一些额外的附加信息</li></ol><h5 id="局部变量表（Local-Variables）"><a href="#局部变量表（Local-Variables）" class="headerlink" title="局部变量表（Local Variables）"></a>局部变量表（<code>Local Variables</code>）</h5><ol><li>存放方法参数和方法内部定义的局部变量</li><li>局部变量表所需的容量大小是在编译期间确定下来的，就在方法的<code>code</code>属性的<code>max_locals</code>数据项中</li><li>存储单元是<code>Slot</code>(变量槽)</li></ol><h5 id="操作数栈-Operand-Stack"><a href="#操作数栈-Operand-Stack" class="headerlink" title="操作数栈(Operand Stack)"></a>操作数栈(<code>Operand Stack</code>)</h5><p>也称为表达式栈。</p><p>操作数栈的深度在编译期间就确定了，保存在方法的<code>code</code>属性的<code>max_stacks</code>中。</p><p><em>栈顶缓存技术</em></p><h5 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(<code>Dynamic Linking</code>)</h5><p><strong>或叫 指向运行时常量池的方法引用</strong></p><h6 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h6><p>静态链接 和 动态链接</p><p><code>非虚方法(解析)</code>：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。“编译期确定，运行期不可变”，有：私有方法，静态方法，父类方法，实例构造器，<code>final</code>方法</p><p>调用方法的字节码指令：</p><ol><li><code>invokestatic</code>:用于调用静态方法</li><li><code>invokespecial</code>:用于调用实例构造器<code>&lt;init&gt;()</code>方法、私有方法和父类方法</li><li><code>invokevirtual</code>:用于调用所有的虚方法</li><li><code>invokeinterface</code>:用于调用接口方法，会在运行时再确定一个实现该接口的对象</li><li><code>invokedynamic</code>:先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法</li></ol><p><del>被<code>invokestatic</code>,<code>invokespecial</code>和被<code>invokevirtual</code>调用的被<code>final</code>修饰的方法都是非虚方法。</del></p><p><strong>修改</strong>：<code>invokestatic</code>调用静态方法，<code>invokespecial</code>调用</p><p>动态分派是很频繁的动作，需要搜索类型元数据。为了优化，在方法区中建立了<code>虚方法表(Virtual Method Table)</code>。虚方法表一般在类加载的连接阶段进行初始化。 </p><h6 id="分派-Dispatch"><a href="#分派-Dispatch" class="headerlink" title="分派(Dispatch)"></a>分派(<code>Dispatch</code>)</h6><ol><li><p>静态分派</p><ol><li>编译器（编译期间）进行的是静态分派。</li><li>虚拟机（编译器）在重载时是通过参数的<strong>静态类型</strong>来确定方法的重载版本的。</li><li>所有依赖静态类型来决定方法执行版本的分派动作，都叫<strong>静态分派</strong></li><li>最典型的表现就是<strong>方法重载</strong></li><li><em>变长参数的重载优先级是最低的</em></li></ol></li><li><p>动态分派</p><ol><li>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派（<strong>运行期间进行的是动态分派</strong>）。</li><li><code>invokevirtual</code>指令时解析过程大致分为以下几步：<ol><li>找到操作数栈顶的第一个元素所指向的对象的<strong>实际类型</strong>,记作<code>C</code></li><li>如果在类型<code>C</code>中找到与常量中的描述符和简单名称都对应的方法，则进行访问权限验证，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回<code>IllegalAccessError</code>异常</li><li>否则，按照继承关系从下往上依次对<code>C</code>的各个父类进行第二步的搜索和验证过程</li><li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常</li></ol></li><li><strong>正是因为<code>invokevirtual</code>第一步就是在运行期确定接收者的实际类型，所以调用过程中不是把常量池中的符号引用解析到直接引用上就结束了。还会根据接收者的实际类型来选择方法版本，这个过程就是方法重写的本质。</strong></li></ol></li><li><p>多分派与单分派</p><ol><li><p>首先来看编译器</p><ol><li><p>编译器进行的是静态分派</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="分派"></p></li><li><p>编译时选择目标方法的依据有两点：一是静态类型是<code>Father</code>还是<code>Son</code>；二是方法参数是<code>QQ</code>还是<code>360</code>。这次方法的选择结果是产生了两条<code>invokevirtual</code>指令，两条指令的参数分别为常量池中指向<code>Father::hardChoice(360)</code>及<code>Father::hardChoice(QQ)</code>方法的符号引用。因为是根据两个宗量进行选择，所以**<code>java</code>语言的静态分派属于多分派类型**</p></li></ol></li><li><p>再看看运行阶段虚拟机的选择，也就是动态分派的过程。</p><ol><li>这时参数的静态类型、实际类型都不会对方法的选择造成任何影响。唯一可以影响选择的因素只有该方法的接受者的实际类型是<code>Father</code>还是<code>Son</code>。因为只有一个宗量可以作为选择依据，所以**<code>java</code>语言的动态分派属于单分派类型**</li></ol></li><li><p><strong>总结：如今(直到Java 12和预览的Java 13)的<code>Java</code>语言是一门 静态多分派、动态单分派的语言。</strong></p><h5 id="方法返回地址（Return-Address）"><a href="#方法返回地址（Return-Address）" class="headerlink" title="方法返回地址（Return Address）"></a>方法返回地址（<code>Return Address</code>）</h5></li></ol></li></ol><p>虚拟机栈中，栈帧作为存储单位，而栈帧中比较重要的结构是 <code>局部变量表</code>和<code>操作数栈</code>；其余三个部分：<code>方法返回地址</code>、<code>附加信息</code>和<code>动态链接</code>可以并称为<code>栈帧信息</code>。</p><p>方法有两种返回类型：</p><ol><li>正常退出。此时 ：主调方法的PC寄存器的值就可以作为返回地址。</li><li>异常退出。此时 ：通过异常处理器表来确定。</li></ol><h5 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h5><p>与调试、性能收集相关的信息。</p><hr><h4 id="虚拟机栈的五道面试题"><a href="#虚拟机栈的五道面试题" class="headerlink" title="虚拟机栈的五道面试题"></a>虚拟机栈的五道面试题</h4><ol><li><p>举例栈溢出的情况？</p><p>答：通过<code>-Xss</code>来设置栈的大小。<code>StackOverflowError</code>,<code>OOM</code></p></li><li><p>调整栈大小，就能保证不出现溢出吗？</p><p>答：不一定。本来就是一个死循环的话……</p></li><li><p>分配的栈内存越大越好吗？</p><p>答： 不是。</p></li><li><p>垃圾回收是否会涉及到虚拟机栈？</p><p>答：不会。</p></li><li><p>方法中定义的局部变量是否线程安全？</p><p>答：<del>是。虚拟机栈是线程安全的。</del>具体情况具体分析。如果局部变量被返回值返回了出去……</p></li></ol><h3 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h3><p><code>native</code></p><p>该部分不属于运行时数据区</p><h3 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈(Native Method Stacks)"></a>本地方法栈(<code>Native Method Stacks</code>)</h3><p>与<code>Java 虚拟机栈</code>类似，<code>Java 虚拟机栈</code>管理<code>Java</code>方法的调用，<code>本地方法栈</code>管理<code>非Java方法</code>的调用。</p><h3 id="堆-Java-Heap"><a href="#堆-Java-Heap" class="headerlink" title="堆(Java Heap)"></a>堆(<code>Java Heap</code>)</h3><p><img src= "/img/loading.gif" data-lazy-src="%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%8F%98%E5%8C%96.png" alt="堆内存的变化"></p><p>堆空间大小的设置：</p><p><code>-Xms</code>和<code>-Xmx</code></p><p><code>-XX:InitialHeapSize</code>和<code>-XX:MaxHeapSize</code></p><p>默认情况下，初始内存大小：物理电脑内存大小 / 64</p><p>最大内存大小：物理电脑内存大小 / 4</p><p><code>-XX:NewRatio=2</code>：默认是2 。代表老年代与新生代的比例。</p><p>在<code>HotSpot</code>中，<code>Eden</code>空间和另外两个<code>Survivor</code>空间缺少所占的比例是<code>8:1:1</code>。 开发人员可以通过<code>-XX:SurvivorRatio</code>调整这个空间比例。比如：<code>-XX:SurvivorRatio=8</code>.</p><p><code>-XX:-UseAdaptiveSizePolicy</code>:关闭自适应的内存分配策略。</p><p><code>-Xmn</code>:设置新生代的空间大小。一般不设置。</p><h4 id="各种GC的对比"><a href="#各种GC的对比" class="headerlink" title="各种GC的对比"></a>各种GC的对比</h4><p><img src= "/img/loading.gif" data-lazy-src="%E5%B8%B8%E8%A7%81GC.png" alt="常见GC"></p><h4 id="总结内存分配策略"><a href="#总结内存分配策略" class="headerlink" title="总结内存分配策略"></a>总结内存分配策略</h4><ul><li>优先分配在<code>Eden</code></li><li>大对象直接进入老年代<ul><li><code>HotSpot</code>虚拟机提供了<code>-XX:PretenureSizeThreshold</code>参数，指定大于该设置值的对象直接分配在老年代。<strong>该参数只对<code>Serial</code>和<code>ParNew</code>两款新生代收集器有效。</strong></li><li>大对象容易导致内存明明还有不少的空间就提前触发垃圾收集。</li></ul></li><li>长期存活的对象将进入老年代<ul><li>默认晋升的阈值是15，可以通过<code>-XX:MaxTenuringThreshold=</code>参数进行设置。</li></ul></li><li>动态对象年龄判定<ul><li>如果在<code>Survivor</code>区中低于或等于某年龄的对象大小的总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到<code>-xx:MaxTenuringThreshold</code>中的数值。</li></ul></li><li>空间分配担保<ul><li>在发生一次<code>Minor GC</code>之前，虚拟机必须检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，则这一次<code>Minor GC</code>可以确保是安全的。</li><li>如果不成立，则先检查<code>-XX:HandlePromotionFailure</code>是否允许担保失败。</li></ul></li></ul><hr><p><code>TLAB</code></p><p>可以通过<code>-XX:+/-UseTLAB</code>来确认是否启用</p><h4 id="代码优化（逃逸分析）"><a href="#代码优化（逃逸分析）" class="headerlink" title="代码优化（逃逸分析）"></a>代码优化（逃逸分析）</h4><p><img src= "/img/loading.gif" data-lazy-src="%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90.png" alt="逃逸分析"></p><p>逃逸可以分为三种类型：</p><ul><li>不逃逸</li><li>方法逃逸<ul><li>当对象在一个方法里面被定义以后，可能被外部方法所引用，例如作为调用参数传递进其它方法中，这种称为方法逃逸。</li></ul></li><li>线程逃逸<ul><li>可能被外部方法访问到，例如赋值给可以在其它线程中访问的实例变量，这种称为线程逃逸。</li></ul></li></ul><h5 id="栈上分配："><a href="#栈上分配：" class="headerlink" title="栈上分配："></a>栈上分配：</h5><p>如果对象没有发生线程逃逸，可以采用栈上分配的策略。</p><p><strong>支持方法逃逸</strong></p><h5 id="标题替换"><a href="#标题替换" class="headerlink" title="标题替换"></a>标题替换</h5><p>如果一个对象不会逃逸出方法，并且这个对象可以被拆分，那么程序真正执行的时候，可能不去创建这个对象，而改为直接创建它的若干个被 这个方法使用的成员变量来代替。</p><h5 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h5><p>如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其它线程访问，那么这个变量的读写就肯定不会有竞争，对这个变量实施的同步措施就可以安全地消除掉。</p><hr><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><h4 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a><code>HotSpot</code>中方法区的演进</h4><p>在<code>jdk 7</code>及以前，习惯上把方法区，称为永久代。<code>jdk 8</code>开始，使用元空间取代了永久代。元空间使用的是直接内存。</p><h4 id="设置方法区大小及OOM"><a href="#设置方法区大小及OOM" class="headerlink" title="设置方法区大小及OOM"></a>设置方法区大小及<code>OOM</code></h4><ol><li>在<code>jdk 7</code>及以前的时候，通过设置永久代的大小来设置方法区的大小：<ol><li><code>-XX:PermSize=N</code>:方法区（永久代）的初始大小</li><li><code>-XX:MaxPermSize=N</code>:方法区（永久代）的最大大小，超过这个值将会抛出<code>OOM:PermGen</code></li></ol></li><li>在<code>jdk 8</code>及以后，通过设置元空间的大小来设置方法区的大小：<ol><li><code>-XX:MetaspaceSize=N</code>:设置<code>Metaspace</code>的初始大小</li><li><code>-XX:MaxMetaspaceSize=N</code>:设置<code>Metaspace</code>的最大大小</li></ol></li></ol><h4 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h4><h4 id="常量池和运行时常量池"><a href="#常量池和运行时常量池" class="headerlink" title="常量池和运行时常量池"></a>常量池和运行时常量池</h4><p><code>class</code>文件中有常量池，内存中有运行时常量池。</p><h4 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h4><p><code>HotSpot</code>中方法区的变化：</p><table><thead><tr><th align="center"><code>jdk</code>版本</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">jdk1.6 及以前</td><td align="center">在永久代(permanent generation)，静态变量存放在永久代上。</td></tr><tr><td align="center">jdk1.7</td><td align="center">在永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中。</td></tr><tr><td align="center">jdk1.8</td><td align="center">无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆。</td></tr></tbody></table><h4 id="StringTable为什么要调整位置？"><a href="#StringTable为什么要调整位置？" class="headerlink" title="StringTable为什么要调整位置？"></a><code>StringTable</code>为什么要调整位置？</h4><p>jdk7中将<code>StringTable</code>放到了堆中。因为永久代的回收效率很低，在<code>full gc</code>的时候都会触发。而<code>full gc</code>是老年代空间不足、永久代不足时才会触发。</p><p>这就导致<code>StringTable</code>回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h4 id="如何证明静态变量放在哪里？"><a href="#如何证明静态变量放在哪里？" class="headerlink" title="如何证明静态变量放在哪里？"></a>如何证明静态变量放在哪里？</h4><h2 id="对象的实例化内存布局与访问定位"><a href="#对象的实例化内存布局与访问定位" class="headerlink" title="对象的实例化内存布局与访问定位"></a>对象的实例化内存布局与访问定位</h2><h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><p><img src= "/img/loading.gif" data-lazy-src="%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.png" alt="对象的实例化"></p><ol><li>加载类元信息</li><li>划分对象的内存空间（为对象分配空间）</li><li>处理并发安全问题</li><li>初始化分配到的空间</li><li>设置对象的对象头</li><li>执行init初始化</li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><h2 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="直接内存(Direct Memory)"></a>直接内存(<code>Direct Memory</code>)</h2><p>缺点：</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul><p>大小可以通过<code>MaxDirectMemorySize</code>设置。</p><hr><h2 id="虚拟机执行引擎"><a href="#虚拟机执行引擎" class="headerlink" title="虚拟机执行引擎"></a>虚拟机执行引擎</h2><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><hr><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a><code>StringTable</code></h2><ul><li>字符串常量池中是不会存储相同的字符串的。</li></ul><h2 id="拼接操作与append操作的效率对比"><a href="#拼接操作与append操作的效率对比" class="headerlink" title="拼接操作与append操作的效率对比"></a>拼接操作与<code>append</code>操作的效率对比</h2><ul><li><code>StringBuilder</code>的<code>append()</code>的方式：自始至终只创建过一个<code>StringBuilder</code>的对象</li><li>使用字符串拼接方式：创建过多个<code>StringBuilder</code>和<code>String</code>的对象<ul><li>内存中由于创建了较多的<code>String</code>和<code>StringBuilder</code>的对象，内存占用更大；如果进行<code>GC</code>， 需要花费更多的时间。</li></ul></li></ul><p>改进的空间：如果基本确定添加的长度不高于某个数值，建议使用<code>StringBuilder(int capacity)</code>的构造器。</p><h2 id="intern-方法的使用"><a href="#intern-方法的使用" class="headerlink" title="intern()方法的使用"></a><code>intern()</code>方法的使用</h2><ul><li>在<code>jdk 1.6</code>及之前：<ul><li>如果字符串常量池中已经有了该字符串，则直接返回该串的地址。</li><li>如果没有该字符串，则将该串复制一份，放入常量池，然后返回池中对串的引用</li></ul></li><li>在<code>jdk 1.7</code>及之后：<ul><li>如果字符串常量池中已经有了该字符串，则直接返回该串的地址。</li><li>如果没有该字符，则在池中引用一下当前堆中串的地址，然后再返回这个地址。</li></ul></li></ul><h2 id="new-String-到底创建了几个对象"><a href="#new-String-到底创建了几个对象" class="headerlink" title="new String()到底创建了几个对象"></a><code>new String()</code>到底创建了几个对象</h2><h2 id="StringTable的垃圾回收问题"><a href="#StringTable的垃圾回收问题" class="headerlink" title="StringTable的垃圾回收问题"></a><code>StringTable</code>的垃圾回收问题</h2><hr><h2 id="垃圾回收相关章节的说明"><a href="#垃圾回收相关章节的说明" class="headerlink" title="垃圾回收相关章节的说明"></a>垃圾回收相关章节的说明</h2><h3 id="什么是垃圾？为什么要GC"><a href="#什么是垃圾？为什么要GC" class="headerlink" title="什么是垃圾？为什么要GC ?"></a>什么是垃圾？为什么要<code>GC </code>?</h3><h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><h3 id="标记阶段相关算法"><a href="#标记阶段相关算法" class="headerlink" title="标记阶段相关算法"></a>标记阶段相关算法</h3><h4 id="引用计数算法-Reference-Counting"><a href="#引用计数算法-Reference-Counting" class="headerlink" title="引用计数算法(Reference Counting)"></a>引用计数算法(<code>Reference Counting</code>)</h4><p>当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>对于一个对象<code>A</code>，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><p>优点：<strong>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性</strong></p><p>缺点：</p><ul><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong></li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong></li><li>引用计数器有一个更严重的问题，即无法处理<strong>循环引用</strong>的情况。这是一条致命缺陷，导致在<code>Java</code>的垃圾回收器中没有使用这类算法。</li></ul><h4 id="可达性分析算法（根搜索算法、追踪性垃圾收集-Tracing-Garbage-Collection-）"><a href="#可达性分析算法（根搜索算法、追踪性垃圾收集-Tracing-Garbage-Collection-）" class="headerlink" title="可达性分析算法（根搜索算法、追踪性垃圾收集(Tracing Garbage Collection)）"></a>可达性分析算法（根搜索算法、追踪性垃圾收集(<code>Tracing Garbage Collection</code>)）</h4><p>所谓<code>GC Roots</code>根集合就是一组必须活跃的引用。</p><p>基本思路：</p><ul><li>可达性分析算法是以根对象集合(<code>GC Roots</code>)为起始点，按照从上到下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong></li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所超过的踒称为引用链(<code>Reference Chain</code>)</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以被标记为垃圾对象</li><li>在可达性分析算法中，只有根对象集合直接或间接连接的对象才是存活对象。</li></ul><h5 id="GC-Roots的选取"><a href="#GC-Roots的选取" class="headerlink" title="GC Roots的选取"></a><code>GC Roots</code>的选取</h5><ol><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象<ol><li>比如：各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量</li></ol></li><li>本地方法栈<code>JNI</code>中引用的对象</li><li>方法区中类静态属性引用的对象<ol><li>如：<code>Java</code>类的引用类型静态变量</li></ol></li><li>方法区中常量引用的对象<ol><li>如：字符串常量池中的引用的对象</li></ol></li><li>所有被同步锁(<code>synchronized</code>关键字)持有的对象</li><li><code>Java</code>虚拟机内部的引用<ol><li>基本数据类型对应的<code>Class</code>对象</li><li>常驻的异常对象</li><li>系统类加载器</li></ol></li><li>反映<code>Java</code>虚拟机内部情况的<code>JMXBean、JVMTI</code>中注册的回调、本地代码缓存等</li></ol><h5 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的<code>finalization</code>机制</h5><p><code>Java</code>虚拟机中的对象可以分为有三种状态：</p><ol><li><code>可触及的</code>：从根结点开始，可以到达这个对象</li><li><code>可复活的</code>：对象的所有引用都被释放，但是对象有可能在<code>finilize()</code>方法中被复活。</li><li><code>不可触及的</code>：对象的<code>finalize()</code>方法被调用，并且没有复活，那么就会进入不可触及状态。 不可触及状态的对象不可能被复活，因为 ** <code>finalize()</code>方法只会被调用一次。**</li></ol><p>以上三种状态中，只有在对象不可被触及时才可被回收。</p><p>判定一个对象<code>objA</code>是否可被回收，至少要经过两次标记过程：</p><ol><li>如果对象<code>objA</code>到<code>GC Roots</code>没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行<code>finalize()</code>方法。<ol><li>如果对象<code>objA</code>没有重写<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，<code>objA</code>被判定为不可触及的</li><li>如果对象<code>objA</code>重写了<code>finalize()</code>方法，且还未执行过，那么<code>objA</code>会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条虚拟机自动建立的、低调度优先级的<code>Finalizer</code>线程去执行它们的<code>finalize()</code>方法。</li><li><strong><code>finalize()</code>方法是对象逃脱死亡的最后机会</strong>，稍后<code>GC</code>会对<code>F-Queue</code>队列中的对象进行第二次标记。如果<code>objA</code>在<code>finalize()</code>方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，<code>objA</code>会被移出<strong>“即将回收”</strong>集合。之后，对象会再次出现没有引用的情况。在这个情况下，<code>finalize</code>方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的<code>finalize()</code>方法只会被调用一次。</li></ol></li></ol><h3 id="清除阶段相关算法"><a href="#清除阶段相关算法" class="headerlink" title="清除阶段相关算法"></a>清除阶段相关算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><h5 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（<code>Mark-Sweep</code>）</h5><p><strong>缺点</strong>：</p><ul><li>执行效率不稳定， 如果Java堆中包含大量对象， 而且其中大部分是需要被回收的， 这时必须进行大量标记和清除的动作， 导致标记和清除两个过程的执行效率都随对象数量增长而降低  </li><li>内存空间的碎片化问题， 标记、 清除之后会产生大量不连续的内存碎片， 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。  </li></ul><h5 id="标记-复制算法（Mark-Coping）"><a href="#标记-复制算法（Mark-Coping）" class="headerlink" title="标记-复制算法（Mark-Coping）"></a>标记-复制算法（<code>Mark-Coping</code>）</h5><p><strong>核心思想：</strong></p><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在作用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><p><strong>缺点</strong>：</p><ul><li>需要两倍的内存空间</li><li>对于<code>G1</code>这种分拆成为大量<code>region</code>的<code>GC</code>，复制而不是移动，意味着<code>GC</code>需要维护<code>region</code>之间是对象引用关系，不管是内存占用还是时间开销也不小</li></ul><p><strong>优点：</strong></p><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题</li></ul><h5 id="标记整理算法（也称为标记-压缩算法）（Mark-Compact）"><a href="#标记整理算法（也称为标记-压缩算法）（Mark-Compact）" class="headerlink" title="标记整理算法（也称为标记-压缩算法）（Mark-Compact）"></a>标记整理算法（也称为标记-压缩算法）（<code>Mark-Compact</code>）</h5><p><strong>优点</strong>：</p><ul><li>消除了标记-清除算法中内存不规整的问题</li><li>消除了标记-复制算法中，内存减半的高额代价。</li></ul><p><strong>缺点</strong>：</p><ul><li>从效率上来说，标记-整理算法要低于复制算法</li><li>移动对象的同时，如果对象被其它对象引用，则还需要调整引用的地址</li><li>移动过程中，需要暂停用户的应用程序，即：<code>STW</code></li></ul><h5 id="对比三种算法"><a href="#对比三种算法" class="headerlink" title="对比三种算法"></a>对比三种算法</h5><table><thead><tr><th align="left"></th><th><code>Mark-Sweep</code></th><th><code>Mark-Compact</code></th><th><code>Copying</code></th></tr></thead><tbody><tr><td align="left">速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td align="left">空间开销</td><td>少（但会产生内存碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的两倍大小（不堆积碎片）</td></tr><tr><td align="left">移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><h5 id="增量收集算法和分区算法"><a href="#增量收集算法和分区算法" class="headerlink" title="增量收集算法和分区算法"></a>增量收集算法和分区算法</h5><p><strong>主要是为了解决<code>STW</code>的问题</strong></p><ul><li>增量收集算法<ul><li>会造成吞吐量的下降</li></ul></li><li>分区算法<ul><li>主要针对<code>G1</code>收集器来说</li><li>将整个堆空间划分为连续的不同的小区间<code>region</code>。</li></ul></li></ul><hr><h2 id="垃圾回收的相关概念"><a href="#垃圾回收的相关概念" class="headerlink" title="垃圾回收的相关概念"></a>垃圾回收的相关概念</h2><h3 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a><code>System.gc()</code>的理解</h3><p>底层就是<code>Runtime.getRuntime().gc()</code></p><h3 id="STW事件的理解"><a href="#STW事件的理解" class="headerlink" title="STW事件的理解"></a><code>STW</code>事件的理解</h3><h3 id="并发（Concurrent）与并行（Parallel）"><a href="#并发（Concurrent）与并行（Parallel）" class="headerlink" title="并发（Concurrent）与并行（Parallel）"></a>并发（<code>Concurrent</code>）与并行（<code>Parallel</code>）</h3><p><strong>垃圾回收的并行：</strong> 多条垃圾回收线程并行工作，但此时用户线程仍处于等待状态。</p><p><strong>垃圾回收的串行</strong>：一条垃圾回收线程工作。</p><p><strong>垃圾回收的并发：</strong>指用户线程与垃圾回收线程同时执行（不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的执行。</p><h3 id="安全点-Safepoint-与安全区域-Safe-Region"><a href="#安全点-Safepoint-与安全区域-Safe-Region" class="headerlink" title="安全点(Safepoint)与安全区域(Safe Region)"></a>安全点(<code>Safepoint</code>)与安全区域(<code>Safe Region</code>)</h3><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>安全点的选取以<strong>“是否具有让程序长时间执行的特征”</strong>。比如：方法调用、循环跳转和异常跳转。</p><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>解决程序“不执行”的问题，比如说程序处于<code>Sleep</code>或者<code>Blocked</code>的状态。</p><p>安全区域：在一段程序代码中，对象的引用关系不会发生变化，在这个区域中的任何位置开始<code>GC</code>都是安全的。</p><p><strong>我们可以把安全区域看成扩展了的安全点。</strong></p><h4 id="抢先式中断和主动式中断"><a href="#抢先式中断和主动式中断" class="headerlink" title="抢先式中断和主动式中断"></a>抢先式中断和主动式中断</h4><p>抢先式中断：（<strong>目前没有采用了</strong>）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点上。</p><p>主动式中断：设置一个中断标志，各个线程运行到<code>Safe Point</code>的时候主动轮询这个标志。如果中断标志为真，则将主动将自己挂起。</p><hr><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>我们希望描述这样一类对象：当内存空间还足够时，能保留在内存中；如果内存空间在进行完垃圾回收后还是很紧张，则可以抛弃这些对象 。</p><p>在<code>JDK1.2</code>后，<code>Java</code>对引用的概念进行了扩充，将引用分为“强引用(<code>Strong Reference</code>)”，“软引用(<code>Soft Reference</code>)”，“弱引用(<code>Weak Reference</code>)”和“虚引用(<code>Phantom Reference</code>)（幽灵引用、幻影引用）”</p><ul><li>强引用：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值。无论在任何情况下，只要强引用还存在，垃圾回收器就不会回收掉被引用的对象。</li><li>软引用 ：<strong>（内存不足才回收。）</strong>在系统将要发生内存溢出之前，将会把这些对象放入回收范围中进行二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。<strong>通常用来实现内存敏感的缓存。</strong></li><li>弱引用：<strong>（发现即回收。）</strong>被弱引用关联的对象只会生存到下次垃圾回收之前。当垃圾回收器工作时，无论内存空间是否足够，都会回收掉被弱引用关联到的对象。<strong>也可以用来保存那些可有可无的缓存。</strong></li><li>虚引用：<strong>（对象回收跟踪。）</strong>一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过一个虚引用来获得一个对象的实例。为一个对象设置虚引用关联的<strong>唯一目的就是能在这个对象被收集器回收时收到一个系统通知。（一定要使用一个队列）</strong></li><li>*终结器引用(<code>Final Reference</code>):*用以实现<code>finalize()</code>方法,无需手动编码,其内部配合引用队列使用.</li></ul><hr><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="1-GC分类与性能指标"><a href="#1-GC分类与性能指标" class="headerlink" title="1.GC分类与性能指标"></a>1.<code>GC</code>分类与性能指标</h3><h4 id="1-按照垃圾回收的线程数分"><a href="#1-按照垃圾回收的线程数分" class="headerlink" title="1. 按照垃圾回收的线程数分"></a>1. 按照垃圾回收的线程数分</h4><p>可以分为串行垃圾回收器和并行垃圾回收器。</p><p>串行回收默认被应用在客户端的<code>Client</code>模式下的<code>JVM</code>中。</p><h4 id="2-按照工作模式分，可以分为"><a href="#2-按照工作模式分，可以分为" class="headerlink" title="2.按照工作模式分，可以分为"></a>2.按照工作模式分，可以分为</h4><p>并发式垃圾回收器和独占式垃圾回收器。</p><h4 id="3-按照碎片处理方式分"><a href="#3-按照碎片处理方式分" class="headerlink" title="3. 按照碎片处理方式分"></a>3. 按照碎片处理方式分</h4><p>压缩式和非压缩式。</p><h4 id="4-按工作的内存空间分"><a href="#4-按工作的内存空间分" class="headerlink" title="4. 按工作的内存空间分"></a>4. 按工作的内存空间分</h4><p>年轻代垃圾回收器和老年代垃圾回收器。</p><h4 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估<code>GC</code>的性能指标</h4><ul><li>吞吐量：运行用户代码的时间占总运行时间的比例。</li><li>垃圾收集开销：吞吐量的补数。</li><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li>内存占用：<code>Java</code>堆区所占的内存大小。</li></ul><h4 id="吞吐量和暂停时间的对比"><a href="#吞吐量和暂停时间的对比" class="headerlink" title="吞吐量和暂停时间的对比"></a>吞吐量和暂停时间的对比</h4><h3 id="2-不同回收器概述"><a href="#2-不同回收器概述" class="headerlink" title="2. 不同回收器概述"></a>2. 不同回收器概述</h3><p><strong>7款经典的垃圾收集器：</strong></p><ul><li>串行垃圾回收器：<code>Serial</code>、<code>Serial Old</code></li><li>并行垃圾回收器：<code>ParNew</code>、<code>Parallel  Scavenge</code>、<code>Parallel Old</code></li><li>并发垃圾回收器：<code>CMS</code>、<code>G1</code></li></ul><p><strong>查看默认的垃圾回收器：</strong><code>-XX:+PrintCommandLineFlags</code></p><h3 id="3-Serial回收器：串行回收"><a href="#3-Serial回收器：串行回收" class="headerlink" title="3.Serial回收器：串行回收"></a>3.<code>Serial</code>回收器：串行回收</h3><p>示意图：</p><p><img src= "/img/loading.gif" data-lazy-src="SerialGC%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SerialGC示意图"></p><p>新生代是标记-复制算法（Eden,from,to,survivor）。老年代是标记-整理算法。</p><p>新生代使用<code>Serial GC</code>，老年代使用<code>Serial Old GC</code>。</p><p><code>Serial Old</code>在<code>Server</code>模式下主要有两个用途：</p><ol><li>与新生代的<code>Parallel</code>配合使用</li><li>作为老年代<code>CMS</code>的后备垃圾收集方案</li></ol><p><strong>优点：</strong></p><ol><li>在内存资源受限的环境，它是所有收集器里<strong>额外内存消耗最小的</strong>。（为保证垃圾收集能够顺利高效进行而存储的额外信息）</li><li>对于单核处理器或者处理器核心较少的环境来说，由于没有线程的交互，专心做垃圾收集可以获得最高的单线程执行效率。</li></ol><h3 id="4-ParNew回收器：-并行回收"><a href="#4-ParNew回收器：-并行回收" class="headerlink" title="4.ParNew回收器： 并行回收"></a>4.<code>ParNew</code>回收器： 并行回收</h3><p><code>ParNew</code>收集器也是<code>Serial</code>收集器的多线程版本。</p><p><strong><code>Par</code>是<code>Parrallel</code>的缩写，<code>New</code>:只能处理的是新生代</strong></p><p>与<code>Serial</code>没有明显区别，共用了相当多的代码。</p><p>新生代使用<strong>标记-复制算法</strong>，老年代使用<strong>标记-整理算法</strong>。</p><p><strong><code>ParNew</code>是很多<code>JVM</code>运行在<code>Server</code>模式下新生代的默认垃圾回收器。</strong></p><p><strong>可以用<code>-XX:+UseParNewGC</code>来指定使用<code>ParNew</code>收集器，可以用<code>-XX:ParallelGCThreads</code>限制线程数量，默认和<code>CPU</code>的数量相同。</strong></p><p>只能与<code>CMS</code>或者<code>Serial Old</code>配合使用。</p><p><strong>在<code>jdk 9</code>的时候，废弃了<code>ParNew</code>+<code>Serial Old</code>，<code>CMS</code>+<code>Serial</code>两种组合，因此<code>ParNew</code>只能与<code>CMS</code>配合使用了。</strong></p><h3 id="5-Parallel回收器：吞吐量优先"><a href="#5-Parallel回收器：吞吐量优先" class="headerlink" title="5.Parallel回收器：吞吐量优先"></a>5.<code>Parallel</code>回收器：吞吐量优先</h3><p>示意图：</p><p><img src= "/img/loading.gif" data-lazy-src="ParallelGC%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ParallelGC示意图"></p><h4 id="Parallel收集器可以分为两个部分："><a href="#Parallel收集器可以分为两个部分：" class="headerlink" title="Parallel收集器可以分为两个部分："></a><code>Parallel</code>收集器可以分为两个部分：</h4><p><code>Parallel Scavenge</code>和<code>Parallel Old</code>，前者针对年轻代，后者针对老年代。</p><h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a><code>Parallel Scavenge</code></h4><ul><li><p>基于标记-复制算法。</p></li><li><p>是一个专注于吞吐量的收集器。提供了两个参数来控制吞吐量。<strong>吞吐量：运行用户代码的时间 占 运行用户代码的时间+<code>GC</code>的时间之和。一般专注于吞吐量的收集器使用标记-压缩(或标记-复制)算法，专注于响应时间（停顿时间、延迟）的收集器使用标记-清除算法。</strong></p></li><li><p>两个用来控制吞吐量的参数：</p><ul><li><code>-XX:MaxGCPauseMillis</code>:设置GC的停顿时间。<strong>值是一个大于0的毫秒数</strong>。降低停顿时间是以提高停顿频率和减少回收空间的大小为代价的。</li><li><code>-XX:GCTimeRatio</code>:<strong>一个大于0小于100的整数。</strong>设置<strong>垃圾收集时间占总时间的比例。</strong></li></ul></li><li><p>还有一个<strong>垃圾回收的自适应的调节策略：</strong></p><ul><li><code>-XX:UseAdaptiveSizePolicy</code>:使用这个参数以后，就不需要手动指定新生代与老年代的比例，<code>Eden</code>与<code>Survivor</code>区的比例，晋升老年代的年龄等细节参数了。</li></ul></li></ul><h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a><code>Parallel Old</code></h4><p>从<code>jdk 6</code>以后才开始使用。</p><p><code>Parallel Old</code>:基于标记-压缩算法。</p><p>在<code>jdk 8</code>中，是默认的收集器。</p><p>参数设置：</p><ul><li><code>-XX:+UseParallelGC</code></li><li><code>-XX:+UseParallelOldGC</code>：这两个参数会相互激活。</li><li><code>-XX:ParallelGCThreads</code>:设置GC线程数。</li><li><code>-XX:MaxGCPauseMillis</code>:</li><li><code>-XX:GCTimeRatio</code>:</li><li><code>-XX:+UseAdaptiveSizePolicy</code>:</li></ul><h3 id="6-CMS回收器：低延迟（Concurrent-mark-sweep）"><a href="#6-CMS回收器：低延迟（Concurrent-mark-sweep）" class="headerlink" title="6.CMS回收器：低延迟（Concurrent-mark-sweep）"></a>6.<code>CMS</code>回收器：低延迟（<code>Concurrent-mark-sweep</code>）</h3><h4 id="第一次实现了让垃圾回收线程与用户线程同时工作"><a href="#第一次实现了让垃圾回收线程与用户线程同时工作" class="headerlink" title="第一次实现了让垃圾回收线程与用户线程同时工作"></a>第一次实现了让垃圾回收线程与用户线程同时工作</h4><p><strong>基于标记-清除算法</strong></p><p><strong>工作原理：</strong></p><ol><li>初始标记（<code>Initial-Mark</code>）:仅仅只是标记出<code>GC Roots</code>能直接关联到的对象。速度非常快。</li><li>并发标记（<code>Concurrent-Mark</code>）:从<code>GC Roots</code>的直接关联对象开始遍历整个对象图的过程。 耗时较长 但是 不需要停顿用户线程。</li><li>重新标记（<code>Remark</code>）:修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录。</li><li>并发清理（<code>Concurrent-Sweep</code>）:清除掉标记阶段判断的已经死亡的对象，释放内存空间。</li></ol><p><strong>相关参数：</strong></p><ul><li><code>-XX:UseConcMarkSweepGC</code>:使用<code>CMS</code>进行垃圾回收，同时年轻代使用<code>ParNew</code>进行收集。</li><li><code>-XX:CMSInitiatingOccu-pancyFraction</code>:开始进行回收的默认的阈值。</li><li><code>-XX:ParallelCMSThreads</code>:线程数量。</li></ul><p><strong>优点：</strong></p><ol><li>并发</li><li>低延迟</li></ol><p><strong>缺点：</strong></p><ol><li>对处理器资源比较敏感</li><li>会产生浮动垃圾，<strong>设置阈值</strong> <strong>（如果<code>CMS</code>运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”(<code>Concurrent Mode Failure</code>)）。并发失败有两种情况：1 是在老年代满之前来不及进行垃圾回收 2是分配新对象没有所需的空间。    “浮动垃圾”：本来可达的对象，在并发之后变得不可达了。这就是“浮动垃圾”。</strong></li><li>产生内存碎片</li></ol><h3 id="7-G1回收器：区域化分代式"><a href="#7-G1回收器：区域化分代式" class="headerlink" title="7. G1回收器：区域化分代式"></a>7. <code>G1</code>回收器：区域化分代式</h3><p>在停顿时间可控的情况下，尽可能获得更高的吞吐量。</p><p><strong>全功能的回收器，可以同时适用于新生代和老年代。</strong></p><p>根据回收的价值大小，优先回收价值收益最大的<code>Region</code>。</p><p><strong>是<code>jdk9</code>以后的默认垃圾回收器。</strong></p><h4 id="优势和不足："><a href="#优势和不足：" class="headerlink" title="优势和不足："></a>优势和不足：</h4><h5 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h5><p>有可预测的时间停顿模型</p><h5 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h5><p>在用户程序运行过程中，无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比<code>CMS</code>要高。</p><h5 id="相关参数："><a href="#相关参数：" class="headerlink" title="相关参数："></a>相关参数：</h5><ul><li><code>-XX:+UseG1GC</code>:手动指定使用<code>G1</code>收集器。<strong>在<code>jdk 9</code>以后，是默认的收集器。不需要手动设置。</strong></li><li><code>-XX:G1HeapRegionSize</code>:取值范围是$1MB-32MB$，且应为2的$N$次幂。**目标是根据最小的<code>Java</code>堆大小划分出约2048个区域。默认是堆内存的$\frac{1}{2000}$**。</li><li><code>-XX:MaxGCPauseMillis</code>:设置期望达到的最大<code>GC</code>停顿时间。默认值是<code>200ms</code>。</li><li><code>-XX:ParallelGCThreads</code>:设置<code>STW</code>工作线程数。</li><li><code>-XX:ConcGCThreads</code>:设置并发标记的线程数。通常设置为并行垃圾回收线程的<code>1/4</code>左右。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code>:设置触发并发<code>GC</code>周期的 <code>Java</code>堆占用率阈值。超过此值，就触发<code>GC</code>。默认值是45. </li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>面向服务端应用，针对具有大内存、多处理器的机器。</li><li>最主要的应用是需要低<code>GC</code>延迟，并具有大堆的应用程序提供解决方案。</li></ul><h5 id="region的介绍"><a href="#region的介绍" class="headerlink" title="region的介绍"></a><code>region</code>的介绍</h5><h5 id="回收环节"><a href="#回收环节" class="headerlink" title="回收环节"></a>回收环节</h5><p><code>G1 GC</code>的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代<code>GC</code>(<code>Young GC</code>)<ul><li>当年轻代Eden区用尽时，开始年轻代垃圾回收过程</li><li>是一个并行的、独占式的收集器</li><li>会暂停所有应用程序进程，启动多线程执行年轻代回收</li></ul></li><li>老年代并发标记过程(<code>Concurrent Marking</code>)<ul><li>当堆内存使用达到一定值（默认45%时），开始老年代并发标记过程</li></ul></li><li>混合回收(<code>Mixed GC</code>)<ul><li>标记完成之后马上开始混合回收过程。对于一个混合回收期，<code>G1 GC</code>从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的<code>G1</code>回收器和其它<code>GC</code>不同，**<code>G1</code>的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的<code>Region</code>就可以了。同时这个老年代<code>Region</code>是和年轻代被一起回收的。**</li></ul></li><li>（如果需要，单线程、独占式、高强度的<code>Full GC</code>还是继续存在的 。它针对<code>GC</code>的评估失败提供了一种失败保护机制，即强力回收。）</li></ul><h4 id="记忆集和写屏障"><a href="#记忆集和写屏障" class="headerlink" title="记忆集和写屏障"></a>记忆集和写屏障</h4><h4 id="具体的回收过程"><a href="#具体的回收过程" class="headerlink" title="具体的回收过程"></a>具体的回收过程</h4><h3 id="8-垃圾回收器总结"><a href="#8-垃圾回收器总结" class="headerlink" title="8. 垃圾回收器总结"></a>8. 垃圾回收器总结</h3><table><thead><tr><th align="center">垃圾收集器</th><th align="center">分类</th><th align="center">作用位置</th><th align="center">使用算法</th><th align="center">特点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center"><code>Serial</code></td><td align="center">串行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">适用于单CPU下的client模式</td></tr><tr><td align="center"><code>ParNew</code></td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">多CPU环境Server模式下与CMS配合使用</td></tr><tr><td align="center"><code>Parallel</code></td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">吞吐量优先</td><td align="center">适用于后台运算而不需要太多交互的场景</td></tr><tr><td align="center"><code>Serial Old</code></td><td align="center">串行</td><td align="center">老年代</td><td align="center">标记-压缩算法</td><td align="center">响应速度优先</td><td align="center">适用于单CPU环境下client模式</td></tr><tr><td align="center"><code>Parallel Old</code></td><td align="center">并行</td><td align="center">老年代</td><td align="center">标记-压缩算法</td><td align="center">吞吐量优先</td><td align="center">适用于后台运算而不需要太多交互的场景</td></tr><tr><td align="center"><code>CMS</code></td><td align="center">并发</td><td align="center">老年代</td><td align="center">标记-清除算法</td><td align="center">响应速度优先</td><td align="center">适用于互联网或B/S业务</td></tr><tr><td align="center"><code>G1</code></td><td align="center">并行</td><td align="center">新生代、老年代</td><td align="center">标记-压缩算法、复制算法</td><td align="center">响应速度优先</td><td align="center">面向服务端应用</td></tr></tbody></table><ul><li><p><code>jdk 8</code>时，弃用了<code>ParNew</code>+<code>Serial Old</code>、<code>Serial</code>+<code>CMS</code>两种组合，这两种组合在<code>jdk 9</code>时，彻底废弃了。</p></li><li><p><code>CMS</code>在<code>jdk9</code>时被弃用了,<code>jdk 14</code>时彻底移除。</p></li><li><p><code>jdk14</code>时，取消了<code>Parallel</code>+<code>Serial Old</code>的组合</p></li><li><p><code>Serial</code>收集器在新生代的各字是<code>Default New Generation</code>，因此显示的是<code>[DefNew</code></p><h3 id="9-GC日志分析"><a href="#9-GC日志分析" class="headerlink" title="9.GC日志分析"></a>9.<code>GC</code>日志分析</h3><h4 id="常用的显示GC日志的参数"><a href="#常用的显示GC日志的参数" class="headerlink" title="常用的显示GC日志的参数"></a>常用的显示<code>GC</code>日志的参数</h4></li></ul><h3 id="10-垃圾回收器的新发展"><a href="#10-垃圾回收器的新发展" class="headerlink" title="10.垃圾回收器的新发展"></a>10.垃圾回收器的新发展</h3><h2 id="JVM类型"><a href="#JVM类型" class="headerlink" title="JVM类型"></a>JVM类型</h2><ol><li>SUN Classic JVM<ol><li>解释器和JIT不能同时使用</li></ol></li><li>Exact VM<ol><li>准确式内存管理</li><li>具备现代高性能虚拟机的雏形<ol><li>热点探测</li><li>编译器和解释器混合工作模式</li></ol></li></ol></li><li>Hotspot虚拟机<ol><li>它的名称中的HotSpot指的就是它的热点代码探测技术</li></ol></li><li>BEA公司的JRockit<ol><li>专注于服务器端应用</li></ol></li><li>IBM 的J9<ol><li>有影响力的三大商用虚拟机之一</li></ol></li><li>KVM和CDC/CLDC HotSpot<ol><li>JavaME产品</li></ol></li><li>Azul VM<ol><li>高性能Java虚拟机中的战斗机</li><li>与特定硬件平台绑定、软硬件配合的专有虚拟机</li></ol></li><li>Liquid VM </li><li>Apache Harmony</li><li>Microsoft JVM</li><li>TaobaoJVM </li><li>Dalvik VM</li><li>Graal VM</li></ol><h2 id="类加载器-1"><a href="#类加载器-1" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="获取类加载器的方法："><a href="#获取类加载器的方法：" class="headerlink" title="获取类加载器的方法："></a>获取类加载器的方法：</h3><ol><li>利用<code>ClassLoader.getSystemClassLoader()</code>方法</li><li>利用某个类的<code>getClassLoader()</code>方法</li><li>获取线程的上下文加载器：<code>Thread.currentThread.getContextClassLoader()</code></li><li>本地方法：<code>DriverManager.getCallerClassLoader()</code></li></ol><h2 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h2><h3 id="堆空间相关的参数"><a href="#堆空间相关的参数" class="headerlink" title="堆空间相关的参数"></a>堆空间相关的参数</h3><ol><li><p><code>-XX:+PrintFlagsInitial</code>:打印参数的初始值</p></li><li><p><code>-XX:+PrintFlagsFinal</code>:打印参数的最终值</p></li><li><p><code>-Xms</code>:堆空间的初始大小（默认为机器内存的1/64）</p></li><li><p><code>-Xmx</code>:堆空间的最大大小（默认为机器内存的1/4）</p></li><li><p><code>-Xmn</code>:新生代的大小</p></li><li><p><code>-XX:SurvivorRatio</code>:</p></li><li><p><code>-XX:NewRatio</code>：</p></li><li><p><code>-XX:MaxTenuringThreshold</code>:设置对象晋升的阈值</p></li><li><p><code>-XX:+PrintGCDetails</code>:输出详细的<code>GC</code>处理日志</p><ol><li><code>-XX:+PrintGC</code>:输出<code>GC</code>日志。类似<code>-verbose:gc</code></li><li><code>-XX:+PrintGCDetails</code>:输出<code>GC</code>的详细日志</li><li><code>-XX:+PrintGCTimeStamps</code>:输出<code>GC</code>的时间戳（以基准时间的形式）</li><li><code>-XX:+PrintGCDateStamps</code>:输出<code>GC</code>的时间戳（以日期的形式）</li><li><code>-XX:+PrintHeapAtGC</code>:在进行<code>GC</code>的前后打印出堆的信息</li><li><code>-Xloggc:../logs/gc.log</code>:日志文件的输出路径</li></ol></li><li><p><code>-XX:HandlePromotionFailure</code>:是否启用空间分配担保。<strong>在<code>jdk6 update24</code> 之后，（JDK7之后），该参数不会再造成影响，始终为<code>true</code></strong></p></li><li><p>-Xss:Java虚拟机栈的大小</p></li><li><p>-Xms:堆的初始大小(年轻代+老年代) 等价于:<code>-XX:InitialHeapSize</code></p></li><li><p>-Xmx:堆的最大大小 等价于：<code>-XX:MaxHeapSize</code></p></li><li><p>默认<code>-XX:NewRatio=2</code>:表示新生代占1，老年代占2，新生代占整个堆的1/3.</p><p>可以修改<code>-XX:NewRatio=4</code>:表示新生代占1，老年代占4，新生代占老年代的1/5.</p></li><li><p><code>-Xmn</code>:设置新生代的最大空间的大小</p></li><li><p><code>-XX:MaxTenuringThreshold=&lt;N&gt;</code>:设置什么时候去养老区</p></li><li><p>```java<br>-XX:+PrintFlagsInitial</p><p>-XX:+PrintFlagsFinal</p><p>-Xmn:设置新生代的大小</p><p>-MaxTenuringThreshold:设置新生代的最大年龄</p><p>//打印GC简要信息<br>-XX:+PrintGC</p><p>-verbose:gc<br>   //JDK7及以后，该参数不会再有实际影响，默认为true<br>-XX:HandlePromotionFailure:是否设置空间分配担保<br>-XX:UseTLAB:设置是否开启TLAB<br>-XX:TLABWasteTargetPercent:设置TLAB空间所占用Edan空间的百分比<br>-XX:+EliminateAllocation:开启了标量替换（默认打开），允许将对象打散分配在栈上。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">18. 代码优化（逃逸分析）：栈上分配、同步省略、标量替换。</span><br><span class="line"></span><br><span class="line">    **逃逸分析只有在服务器端才能开启，参数：&#96;-server&#96;**</span><br><span class="line"></span><br><span class="line">19. </span><br><span class="line"></span><br><span class="line">## 关于对象分配过程的总结</span><br><span class="line"></span><br><span class="line">1. 针对幸存者S0，S1区的总结：复制之后有交换，谁空谁是to</span><br><span class="line">2. 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不再永久区&#x2F;元空间收集。</span><br><span class="line"></span><br><span class="line">## 为对象分配内存：TLAB</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 中篇 类文件结构 和 类的加载器</span><br><span class="line"></span><br><span class="line">## &#96;class&#96;文件结构</span><br><span class="line"></span><br><span class="line">&#96;javac&#96;是一种能够将&#96;java&#96;源码翻译成字节码的**前端编译器**</span><br><span class="line"></span><br><span class="line">- 什么是字节码指令（&#96;byte code&#96;）？</span><br><span class="line">&#96;Java&#96;虚拟机的指令由一个字节长度的、代表某种特定操作含义的操作码（opcode)，以及其后的零至多个代表此操作所需参数的操作数(&#96;operand&#96;）所构成，虚拟机中许多指令并不包含操作数，只有一个操作码。</span><br><span class="line">比如：操作码 操作数</span><br><span class="line">- 整个&#96;class&#96;文件本质上也是一张表，表习惯上以&#96;_info&#96;结尾</span><br><span class="line">### &#96;class&#96;文件总体结构概述</span><br><span class="line"></span><br><span class="line">![class文件结构](class文件结构.png)</span><br><span class="line"></span><br><span class="line">#### 1、开头四个字节的魔数 &#96;magic&#96;</span><br><span class="line"></span><br><span class="line">#### 2、接下来是2个字节的主版本号、2个字节的次版本号。</span><br><span class="line"></span><br><span class="line">版本号的对应关系如下：</span><br><span class="line"></span><br><span class="line">| 主版本（十进制） | 副版本（十进制） | 编译器版本 |</span><br><span class="line">| --------------- | --------------- | ---------- |</span><br><span class="line">| 45              | 3               | 1.1        |</span><br><span class="line">| 46              | 0               | 1.2        |</span><br><span class="line">| 47              | 0    | 1.3        |</span><br><span class="line">| 48              | 0               | 1.4        |</span><br><span class="line">| 49              | 0               | 1.5        |</span><br><span class="line">| 50              | 0               | 1.6        |</span><br><span class="line">| 51              | 0               | 1.7        |</span><br><span class="line">| 52              | 0               | 1.8        |</span><br><span class="line">| 53              | 0               | 1.9        |</span><br><span class="line">| 54              | 0               | 1.10       |</span><br><span class="line">| 55              | 0               | 1.11       |</span><br><span class="line"></span><br><span class="line">#### 3、常量池</span><br><span class="line"></span><br><span class="line">&#96;数据池表项&#96;中，用于存放编译时生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区中的&#96;运行时常量池&#96;中存放。</span><br><span class="line"></span><br><span class="line">##### 1、常量池计数器&#96;constant_pool_count&#96;</span><br><span class="line"></span><br><span class="line">##### 2、常量池表&#96;constant_pool[contant_pool_count-1]&#96;</span><br><span class="line"></span><br><span class="line">###### 1、&#96;字面量(Literal)&#96;和&#96;符号引用(Symbolic References)&#96;</span><br><span class="line"></span><br><span class="line">|   常量   |      具体的常量       |</span><br><span class="line">| -------- | -------------------- |</span><br><span class="line">| 字面量   | 文本字符串            |</span><br><span class="line">|          | 声明为&#96;final&#96;的常量值 |</span><br><span class="line">| 符号引用 | 类和接口的全限定名     |</span><br><span class="line">|          | 字段的名称和描述符     |</span><br><span class="line">|          | 方法的名称和描述符     |</span><br><span class="line"></span><br><span class="line">1. 全限定名</span><br><span class="line">            &#96;com&#x2F;example&#x2F;yzc35326&#x2F;Demo&#96;</span><br><span class="line">        </span><br><span class="line">1. 简单名称</span><br><span class="line">        没有类型和参数修饰的方法或者字段名称，例如&#96;add()&#96;方法和&#96;num&#96;字段的简单名称分别是&#96;add&#96;和&#96;num&#96;。</span><br><span class="line">    </span><br><span class="line"> 1. 描述符</span><br><span class="line">        描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</span><br><span class="line"></span><br><span class="line">     ![域描述符](域描述符.png)</span><br><span class="line"></span><br><span class="line">1. 访问标识&#96;(access_flag、访问标志、访问标记)&#96;</span><br><span class="line"></span><br><span class="line">    在常量池后，紧跟着的就是访问标记，该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个class是类还是接口；是否定义为public类型；如果是类的话，是否被声明为final等。访问标记如下所示：</span><br><span class="line"></span><br><span class="line">    |标志名称|标志值|含义|</span><br><span class="line">    | :----: | :----: | :---:  |</span><br><span class="line">    | ACC_PUBLIC | 0x0001 | public |</span><br><span class="line">    | ACC_FINAL | 0x0010 | final |</span><br><span class="line">    |ACC_SUPER|0x0020|标志允许使用&#96;invokespecial&#96;的字节码指令的新语义，&#96;jdk&#96;1.0.2之后编译出来的类的这个标志默认为真（使用增强的方法调用父类方法）|</span><br><span class="line">    |ACC_INTERFACE|0x0200|标志这是一个接口|</span><br><span class="line">    |ACC_ABSTRACT|0x0400|是否为abstract类型，对于抽象类或者接口来说，此标志为真，其它类型为假|</span><br><span class="line">    |ACC_SYNTHETIC|0x1000|标志此类不是由用户代码产生（由编译器产生的，代码对应）|</span><br><span class="line">    |ACC_ANNOTATION|0x2000|标志这是一个注解|</span><br><span class="line">    |ACC_ENUM|0x4000|标志这是一个枚举|</span><br><span class="line"></span><br><span class="line">##### 3、属性表集合</span><br><span class="line"></span><br><span class="line">###### 属性表的通用格式</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">attribute_info&#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>一共有23种属性。</p><h6 id="1、The-ConstantValue-Attribute"><a href="#1、The-ConstantValue-Attribute" class="headerlink" title="1、The ConstantValue Attribute"></a>1、<code>The ConstantValue Attribute</code></h6><h6 id="2、The-Code-Attribute"><a href="#2、The-Code-Attribute" class="headerlink" title="2、The Code Attribute"></a>2、<code>The Code Attribute</code></h6><h6 id="3、The-StackMapTable-Attribute"><a href="#3、The-StackMapTable-Attribute" class="headerlink" title="3、The StackMapTable Attribute"></a>3、<code>The StackMapTable Attribute</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StackMapTable_attibute&#123;</span><br><span class="line">    u2attribute_name_index;</span><br><span class="line">    u4attribute_length;</span><br><span class="line">    u2number_of_entries;</span><br><span class="line">    stack_map_frameentries[number_of_entries];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>attribute_name_index</code></p><p>常量池中这个索引处必须是一个<code>CONSTANT_Utf8_info</code>类型的值，该值必须是<code>StackMapTable</code></p></li><li><p><code>attribute_length</code></p><p>这个参数的长度</p></li><li><p><code>number_of_entries</code></p><p>条目表中<code>stack_map_frame</code>的长度</p></li><li><p><code>entries</code></p><p>每个<code>entries</code>代表一个帧</p></li></ol><h5 id="4、The-Exceptions-Attribute"><a href="#4、The-Exceptions-Attribute" class="headerlink" title="4、The Exceptions Attribute"></a>4、<code>The Exceptions Attribute</code></h5><h5 id="5、The-InnerClasses-Attribute"><a href="#5、The-InnerClasses-Attribute" class="headerlink" title="5、The InnerClasses Attribute"></a>5、<code>The InnerClasses Attribute</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InnerClasses_attribue &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 number_of_classes;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 inner_class_info_index;</span><br><span class="line">        u2 outer_class_info_index;</span><br><span class="line">        u2 inner_name_index;</span><br><span class="line">        u2 inner_class_access_flags;</span><br><span class="line">    &#125; classes[number_of_classes];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>attribute_name_index</code></p><p>指向<code>InnerClasses</code></p></li><li><p><code>attribute_length</code></p><p>指明属性的长度</p></li><li><p><code>number_of_classes</code></p><p>指明下面的<code>classes</code>表中的条目数</p></li><li><p><code>classes[]</code></p><p>每一个条目都代表一个内部类或者接口</p><ol><li><p><code>inner_class_info_index</code></p><p>指向常量池中对内部类的引用</p></li><li><p><code>outer_class_info_index</code></p><p>如果该类不是一个内部类，这个索引必须是0.否则这个索引指向常量池中一个<code>Constant_Utf8_info</code>的值，这个值指的是外部类的名字。</p><p>不是内部类的情况：</p><ol><li>是一个顶层类或一个顶层接口，也就是类文件层次的类和接口</li><li>局部类。比如代码快中的类</li><li>匿名类</li></ol></li><li><p><code>inner_name_index</code></p><ol><li>如果这个类是匿名内部类，这个值必须是0</li><li>否则，指向常量池中这个内部类的简单名字</li></ol></li><li><p><code>inner_class_access_flags</code></p></li></ol></li></ol><h5 id="6、-The-EnclosingMethod-Attribute"><a href="#6、-The-EnclosingMethod-Attribute" class="headerlink" title="6、 The EnclosingMethod Attribute"></a>6、 <code>The EnclosingMethod Attribute</code></h5><h5 id="7、The-Synthetic-Attribute"><a href="#7、The-Synthetic-Attribute" class="headerlink" title="7、The Synthetic Attribute"></a>7、<code>The Synthetic Attribute</code></h5><h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><h3 id="1、局部变量压栈指令"><a href="#1、局部变量压栈指令" class="headerlink" title="1、局部变量压栈指令"></a>1、局部变量压栈指令</h3><p>这类指令大体可以分为：</p><blockquote><p>xload_&lt;n&gt; (x为i、l、f、d、a, n为 0到3)</p><p>xload(x为i、l、d、f、a)</p></blockquote><p><strong>注意：</strong>这里的n代表的是索引</p><h3 id="2、常量入栈指令"><a href="#2、常量入栈指令" class="headerlink" title="2、常量入栈指令"></a>2、常量入栈指令</h3><p>将常数压入操作数栈。</p><p>根据数据类型和入栈内容的不同，又可以分为<code>const</code>系列、<code>push</code>系列和<code>ldc</code>指令。</p><h4 id="1、指令const系列（对于特定的常量入栈，入栈的常量隐含在指令本身里）"><a href="#1、指令const系列（对于特定的常量入栈，入栈的常量隐含在指令本身里）" class="headerlink" title="1、指令const系列（对于特定的常量入栈，入栈的常量隐含在指令本身里）"></a>1、指令<code>const</code>系列（对于特定的常量入栈，入栈的常量隐含在指令本身里）</h4><p>指令有：</p><blockquote><p>iconst_&lt;i&gt;(i从-1到5)，-1用m1表示</p><p>lconst_&lt;l&gt;(l从0到1)</p><p>dconst_&lt;d&gt;(d从0到1)</p><p>fconst_&lt;f&gt;(f从0到2)</p><p>aconst_null(引用数据类型默认赋null值)</p></blockquote><h4 id="2、指令push系列"><a href="#2、指令push系列" class="headerlink" title="2、指令push系列"></a>2、指令<code>push</code>系列</h4><p>主要包括<code>bipush</code>和<code>sipush</code>.它们的区别在于接收数据类型的不同。<code>bipush</code>接收8位整数做为参数；<code>sipush</code>接收16位整数。它们都将参数压入栈。</p><h4 id="3、指令ldc系列"><a href="#3、指令ldc系列" class="headerlink" title="3、指令ldc系列"></a>3、指令<code>ldc</code>系列</h4><ul><li>如果以上指令不能满足需求，那么可以使用万能的<code>ldc</code>指令。它可以接收一个8位的参数。该参数指向常量池中的<code>int</code> <code>float</code>或<code>String</code>类型的索引，将指定的内容压入栈中。</li><li>类似的还有<code>ldc_w</code>，它接收两个8位参数。能支持的索引范围大于<code>ldc</code></li><li>如果要压入的元素是<code>long</code>或者<code>double</code>类型的，则使用<code>ldc2_w</code>指令。使用方式都是类似的。</li></ul><h4 id="总结如下："><a href="#总结如下：" class="headerlink" title="总结如下："></a>总结如下：</h4><table><thead><tr><th align="center">类型</th><th align="center">常数指令</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">int(boolean,byte,char,short)</td><td align="center">iconst</td><td align="center">[-1,5]</td></tr><tr><td align="center"></td><td align="center">bipush</td><td align="center">[-128,127]</td></tr><tr><td align="center"></td><td align="center">sipush</td><td align="center">[-32768,32767]</td></tr><tr><td align="center"></td><td align="center">ldc</td><td align="center">any int value</td></tr><tr><td align="center">long</td><td align="center">lconst</td><td align="center">0,1</td></tr><tr><td align="center"></td><td align="center">ldc</td><td align="center">any long value</td></tr><tr><td align="center">float</td><td align="center">fconst</td><td align="center">0,1,2</td></tr><tr><td align="center"></td><td align="center">ldc</td><td align="center">any float value</td></tr><tr><td align="center">double</td><td align="center">dconst</td><td align="center">0,1</td></tr><tr><td align="center"></td><td align="center">ldc</td><td align="center">any double value</td></tr><tr><td align="center">references</td><td align="center">aconst</td><td align="center">null</td></tr><tr><td align="center"></td><td align="center">ldc</td><td align="center">String literal,Class literal</td></tr></tbody></table><h4 id="4、出栈装入局部变量表指令"><a href="#4、出栈装入局部变量表指令" class="headerlink" title="4、出栈装入局部变量表指令"></a>4、出栈装入局部变量表指令</h4><p>用于将操作数栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。</p><h3 id="3、算术指令"><a href="#3、算术指令" class="headerlink" title="3、算术指令"></a>3、算术指令</h3><h4 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h4><p>用于对两个操作数栈一的值进行某种特定运算，并把结果重新压入操作数栈。</p><h4 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h4><p>大体上自述指令可以分为两种：对<code>整型数据</code>进行运算的指令和对<code>符点型数据</code>进行运算的指令。</p><h4 id="3、byte、short、char和boolean类型说明"><a href="#3、byte、short、char和boolean类型说明" class="headerlink" title="3、byte、short、char和boolean类型说明"></a>3、byte、short、char和boolean类型说明</h4><h4 id="4、比较指令的说明"><a href="#4、比较指令的说明" class="headerlink" title="4、比较指令的说明"></a>4、比较指令的说明</h4><ul><li>比较指令的作用是比较栈顶的两个元素，并将比较结果入栈。</li><li>比较指令有：<code>dcmpg,dcmpl,fcmpg,fcmpl和lcmp</code><ul><li>与前面的讲解的指令类似，首字符<code>d</code>表示<code>double</code>类型，<code>f</code>表示<code>float</code>类型,<code>l</code>表示<code>long</code>类型</li></ul></li><li>对于<code>double</code>和<code>float</code>类型的数字，由于<code>NaN</code>的存在，各有两个版本的比较指令。以<code>float</code>为例，有<code>fcmpg</code>和<code>fcmpl</code>两个指令，它们的区别在于数字比较时，若遇到<code>NaN</code>值，处理结果不同</li><li>指令<code>lcmp</code>对于<code>long</code>型整数，由于<code>long</code>类型没有<code>NaN</code>值，故无需准备两套指令。</li></ul><p>举例：</p><p>指令<code>fcmpg</code>和<code>fcmpl</code>都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为<code>v2</code>，栈顶顺位第2位的元素为<code>v1</code>，若<code>v1=v2</code>，则压入0；若<code>v1&gt;v2</code>，则压入1；若<code>v1&lt;v2</code>，则压入-1.</p><p>两个指令的不同之处在于，如果遇到<code>NaN</code>值，<code>fcmpg</code>会压入1，而<code>fcmpl</code>会压入-1</p><h3 id="4、类型转换指令"><a href="#4、类型转换指令" class="headerlink" title="4、类型转换指令"></a>4、类型转换指令</h3><h5 id="1、宽化类型转换"><a href="#1、宽化类型转换" class="headerlink" title="1、宽化类型转换"></a>1、宽化类型转换</h5><p>从byte、short、char到short类型的宽化类型转换实际上是不存在的</p><h5 id="2、窄化类型转换"><a href="#2、窄化类型转换" class="headerlink" title="2、窄化类型转换"></a>2、窄化类型转换</h5><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>当将一个浮点值窄化转换成整数类型T（T限于int或long类型之一）的时候，将遵循以下转换规则：</p><ul><li>如果浮点值是<code>NaN</code>，则转换结果就是int或long类型的0</li><li>如果浮点值不是无穷大的话，浮点值使用<code>IEEE 754</code>的向零舍入模式取整，获得整数<code>v</code>。如果<code>v</code>在目标类型的表示范围之内，那转换结果就是<code>v</code>。如果浮点值是无穷大的话，则根据<code>v</code>的符号，转换为T所能表示的最大或最小无穷大。</li></ul><p>当将一个double类型窄化转换为float类型时，将遵循以下转换规则：</p><p>通过向最接近数字舍入模式会得到一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断：</p><ul><li>如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零。</li><li>如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大。</li><li>对于double类型的NaN值将按规定转换为float类型的NaN值</li></ul><h3 id="5、对象的创建与访问指令"><a href="#5、对象的创建与访问指令" class="headerlink" title="5、对象的创建与访问指令"></a>5、对象的创建与访问指令</h3><h4 id="1、创建指令"><a href="#1、创建指令" class="headerlink" title="1、创建指令"></a>1、创建指令</h4><h5 id="1、创建类实例的指令：new"><a href="#1、创建类实例的指令：new" class="headerlink" title="1、创建类实例的指令：new"></a>1、创建类实例的指令：<code>new</code></h5><p>它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈</p><h5 id="2、创建数组的指令"><a href="#2、创建数组的指令" class="headerlink" title="2、创建数组的指令"></a>2、创建数组的指令</h5><p><code>newarray</code>、<code>anewarray</code>、<code>multianewarray</code></p><ul><li><code>newarray</code>:创建基本类型数组</li><li><code>anewarray</code>:创建引用类型数组</li><li><code>multianewarray</code>:创建多维数组</li></ul><h4 id="2、字段访问指令"><a href="#2、字段访问指令" class="headerlink" title="2、字段访问指令"></a>2、字段访问指令</h4><ul><li>访问类字段(<code>static</code>字段，或者称为类变量)的指令：<code>getstatic</code>，<code>putstatic</code></li><li>访问实例字段(非<code>static</code>字段，或者称为实例变量)的指令：<code>getfield</code>，<code>putfield</code></li></ul><h4 id="3、数组操作指令"><a href="#3、数组操作指令" class="headerlink" title="3、数组操作指令"></a>3、数组操作指令</h4><p>数组操作指令主要有：<code>xastore</code>和<code>xaload</code>指令。具体为：</p><ul><li><p>把一个数组元素加载到操作数栈中的指令:</p><blockquote><p>iaload laload faload daload sload baload caload aaload</p></blockquote></li><li><p>把一个操作数栈的值存储到数组元素中的指令：</p><blockquote><p>bastore castore sastore iastore lastore dastore fastore</p></blockquote></li></ul><p><strong><code>boolead</code>数组类型也用的是<code>b</code></strong></p><ul><li>取数组长度的指令：<code>arraylength</code><ul><li>该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈</li></ul></li></ul><h4 id="4、类型检查指令"><a href="#4、类型检查指令" class="headerlink" title="4、类型检查指令"></a>4、类型检查指令</h4><p>检查类实例或者数组类型的指令：instanceof、checkcast</p><ul><li>指令checkcast用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则会抛出ClassCastException异常</li><li></li></ul><hr><h2 id="类的主动使用"><a href="#类的主动使用" class="headerlink" title="类的主动使用"></a>类的主动使用</h2><p><code>JVM</code>规范中规定了类<strong>初始化</strong>的时机只有六种情况，这六种情况被称为主动使用：</p><ol><li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这四条字节码指令时，能够生成这六种字节码指令的场景有：<ol><li>使用<code>new</code>关键字新建对象的时候</li><li>访问类或接口的静态字段的时候。<strong>但是被<code>final</code>修饰，已在编译期将数值放入常量池中的字段除外</strong></li><li>调用类的静态方法，接口的静态方法</li></ol></li><li>使用反射创建新的对象的时候</li><li>当初始化类的时候，要将其父类进行初始化</li><li>虚拟机的启动类</li><li><code>Java SE7</code>中新加入的动态语言支持</li><li>如果一个接口中定义了<code>jdk 1.8</code>中引入的默认方法的时候，如果有这个接口的实现类发生了初始化，那么该接口要在其之前被初始化</li></ol><p><strong>注意：</strong>一个接口初始化时，并不要求它的所有父接口也初始化，只有访问父接口中的字段的时候才初始化！！</p><p>在初始化一个类的时候，也不会初始化它所实现的接口！！</p><p>但是！！如果这个接口中有default方法，就会初始化这个接口。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的assert关键字</title>
      <link href="2020/12/03/java%E4%B8%AD%E7%9A%84assert%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2020/12/03/java%E4%B8%AD%E7%9A%84assert%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1399543">关于Java中的assert关键字 - 云+社区 - 腾讯云 (tencent.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> assert </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> assert </tag>
            
            <tag> 关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解java中的枚举</title>
      <link href="2020/12/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE/"/>
      <url>2020/12/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/javazejian/article/details/71333103">深入理解Java枚举类型(enum)_zejian的博客-CSDN博客_enum</a></p><p>链接：<a href="https://blog.csdn.net/javazejian/article/details/71333103">https://blog.csdn.net/javazejian/article/details/71333103</a></p><h2 id="如何自定义枚举类"><a href="#如何自定义枚举类" class="headerlink" title="如何自定义枚举类"></a>如何自定义枚举类</h2><p>枚举类是一组<strong>常量</strong></p><ol><li><p>在<code>jdk 5.0</code>之前，需要自定义枚举类</p><p><strong>用<code>class</code>实现或者用<code>enum</code>关键字</strong></p></li><li><p>在<code>jdk5.0</code>及之后，使用<code>Enum</code>关键字定义枚举类</p></li></ol><h2 id="如何使用关键字enum定义枚举类"><a href="#如何使用关键字enum定义枚举类" class="headerlink" title="如何使用关键字enum定义枚举类"></a>如何使用关键字enum定义枚举类</h2><h2 id="Enum类的主要方法"><a href="#Enum类的主要方法" class="headerlink" title="Enum类的主要方法"></a>Enum类的主要方法</h2><h2 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="实现接口的枚举类"></a>实现接口的枚举类</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
          <category> 枚举类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
            <tag> 枚举 </tag>
            
            <tag> Enum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式整理</title>
      <link href="2020/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/"/>
      <url>2020/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><ul><li>单一职责原则(<code>Single Responsibility</code>)<ul><li>一个类只负责一项职责</li><li><strong>分为类级别和方法级别</strong><span id="more"></span></li></ul></li><li>接口隔离原则(<code>Interface Segregation Principle</code>)<ul><li>一个类对另一个类的依赖应该建立在最小的接口上</li></ul></li><li>依赖倒置原则(<code>Dependence Inversion Principle</code>)<ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒置（倒转）的中心思想的<strong>面向接口编程</strong></li></ol></li><li>里氏替换原则<ul><li>所有引用基类的地方必须能透明地使用其子类</li></ul></li><li>开闭原则(<code>Open Closed Principle</code>)<ul><li>对扩展开放，对修改关闭</li></ul></li><li>迪米特法则(<code>Demeter Principle</code>)<ul><li>只与直接的朋友通信</li><li><strong>直接的朋友：</strong>成员变量、返回值、方法参数</li></ul></li><li>合成复用原则(<code>Composite Reuse Principle</code>)<ul><li>尽量使用<code>组合/聚合</code>的方式,而不要使用继承</li></ul></li></ul><hr><h2 id="设计模式分类："><a href="#设计模式分类：" class="headerlink" title="设计模式分类："></a>设计模式分类：</h2><p>一共有23种：</p><ol><li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</li><li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</li><li>行为型模式：模板方法模式工、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）</li></ol><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ol><li>饿汉式（静态常量）</li><li>饿汉式（静态代码块）</li><li>懒汉式（线程不安全）</li><li>懒汉式（线程安全，同步方法）</li><li>懒汉式（线程安全，同步代码块）</li><li>双重检查：推荐使用</li><li>静态内部类：推荐使用</li><li>枚举：推荐使用，但是在<code>Android</code>平台不建议，使用内存太大</li></ol><p>在JDK源码中的应用：<code>Runtime</code>类</p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>定义了一个创建对象的类，由这个类来封装实例化对象的行为。</p><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>定义一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类</p><h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>将工厂抽象成两层，<code>AbsFactory(抽象工厂)</code>和<code>具体实现的工厂子类</code>。</p><p>从设计层面看，抽象工厂是对简单工厂模式的改进<em>（或者是进一步的抽象）</em></p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>用原型实例指定创建对象的各类，并且通过拷贝这些原型，创建新的对象</p><p>实现深拷贝的两种方法：</p><ol><li>实现<code>Cloneable</code>接口，重写<code>clone()</code>方法</li><li>序列化</li></ol><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>类图：<img src= "/img/loading.gif" data-lazy-src="%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="建造者模式类图"></p><p>基本介绍：将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方法桃心构造出不同表现的对象。</p><p>角色分析：</p><ol><li><code>Product</code>:一个具体的产品对象</li><li><code>Builder</code>:抽象建造者。定义建造产品的抽象方法。</li><li><code>ConcreteBuilder</code>:具体的建造者。实现建造产品的抽象方法。</li><li><code>Director</code>:指挥者。</li></ol><h5 id="在JDK源码中的应用：StringBuilder"><a href="#在JDK源码中的应用：StringBuilder" class="headerlink" title="在JDK源码中的应用：StringBuilder"></a>在<code>JDK</code>源码中的应用：<code>StringBuilder</code></h5><p>分析：</p><ol><li><code>Appendable</code>接口：抽象的建造者</li><li><code>AbstractStringBuilder</code>抽象类:实现了<code>append()</code>方法，是具体的建造者，只是不能实例化</li><li><code>StringBuilder</code>类:指挥者，也是产品。</li></ol><hr><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>可以分为<strong>类适配器、对象适配器、接口适配器</strong></p><h5 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h5><p>也称为<strong>适配器模式</strong>或者<strong>缺省适配器模式</strong></p><p>核心思想： 如果不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口的每个方法提供一个默认实现（空方法），那么该抽象类的子类可以有选择地覆盖父类的某些方法来实现需求。<em>适用于一个接口不想使用其所有的方法的情况</em></p><p>三种命名方式，是根据<code>src</code>是以怎样的形式给到 <code>Adapter</code>（在<code>Adapter</code>里的形式）来命名的</p><ol><li>类适配器：以类给到，在<code>Adapter</code>里，就是将<code>src</code>当做类，继承</li><li>对象适配器：以对象给到，在<code>Adapter</code>里，就是将<code>src</code>作为一个对象，持有</li><li>接口适配器：以接口给到，在<code>Adapter</code>里，将<code>src</code>作为一个接口，实现</li></ol><p>实际开发中，不局限于这三种形式</p><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>两个独立变化的维度。</p><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>装饰器类似于打包快递。</p><p>动态的将新功能附加到对象上。</p><p>装饰者继承于被装饰者，并且含有一个被装饰者。</p><h5 id="在JDK源码IO体系中的应用"><a href="#在JDK源码IO体系中的应用" class="headerlink" title="在JDK源码IO体系中的应用"></a>在<code>JDK</code>源码<code>IO</code>体系中的应用</h5><p><img src= "/img/loading.gif" data-lazy-src="JavaIO.png" alt="Java IO体系"></p><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>对象树形结构</p><h5 id="在JDK源码-HashMap中的应用"><a href="#在JDK源码-HashMap中的应用" class="headerlink" title="在JDK源码 HashMap中的应用"></a>在<code>JDK</code>源码 <code>HashMap</code>中的应用</h5><ol><li><code>Map</code>接口：抽象的<code>component</code></li><li><code>HashMap</code>: 相当于普通结点 有<code>put</code>、<code>putAll</code>方法</li><li><code>Node</code>: 是<code>HashMap</code>的静态内部类 相当于叶子结点</li><li><code>AbstractMap</code>: 多做了一层数据结构 对<code>Map</code>接口做了一些实现</li></ol><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>对子系统提供统一的接口，屏蔽子系统的内部实现细节</p><h5 id="在MyBatis框架的应用"><a href="#在MyBatis框架的应用" class="headerlink" title="在MyBatis框架的应用"></a>在<code>MyBatis</code>框架的应用</h5><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>共享对象</p><p>“享”：共享</p><p>“元”：对象</p><p><img src= "/img/loading.gif" data-lazy-src="%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" alt="享元模式类图"></p><h4 id="在Integer中的应用"><a href="#在Integer中的应用" class="headerlink" title="在Integer中的应用"></a>在<code>Integer</code>中的应用</h4><ol><li><p><code>IntegerCache</code>: 相当于<code>ConcreteFlyweight</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123; <span class="comment">// Integer的静态内部类</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Integer</code>:相当于<code>FlyweightFactory</code></p></li></ol><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理模式可分为三种：</p><ol><li>静态代理：被代理对象和代理对象<strong>实现相同的接口</strong>或者<strong>继承相同的父类</strong>，代理对象持有被代理对象</li><li>动态代理： 也叫JDK代理或者接口代理，被代理类必须实现接口</li><li><code>Cglib</code>代理：子类代理</li></ol><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>在父类中定义方法的模板</p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>将请求者和执行者解耦</p><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><h5 id="在JDK源码-ArrayList中的应用"><a href="#在JDK源码-ArrayList中的应用" class="headerlink" title="在JDK源码 ArrayList中的应用"></a>在<code>JDK</code>源码 <code>ArrayList</code>中的应用</h5><ol><li><code>Iterator</code>接口:  迭代器接口</li><li><code>List</code>接口：充当聚合接口，含有一个<code>iterator()</code>方法，返回一个迭代器对象</li><li><code>ArrayList</code>： 具体实现<code>List</code>接口的类</li><li>内部类<code>Itr</code>: 实现<code>Iterator</code>接口的具体的迭代器</li></ol><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><img src= "/img/loading.gif" data-lazy-src="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式类图"></p><ol><li><code>Subject</code>:登记注册、移除和通知<ol><li><code>registerObserver</code>: 注册</li><li><code>removeObserver</code>: 移除</li><li><code>notifyObservers()</code>: 通知所有的注册的观察者</li></ol></li><li><code>Observere</code>:接收输入</li></ol><h5 id="在jdk源码-Observable类中的应用"><a href="#在jdk源码-Observable类中的应用" class="headerlink" title="在jdk源码 Observable类中的应用"></a>在<code>jdk</code>源码 <code>Observable</code>类中的应用</h5><ol><li><code>Observable</code>的作用和地位等价于<code>Subject</code></li></ol><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><h5 id="在JDK中-Arrays的应用"><a href="#在JDK中-Arrays的应用" class="headerlink" title="在JDK中 Arrays的应用"></a>在<code>JDK</code>中 <code>Arrays</code>的应用</h5><h4 id="职责链（责任链）模式"><a href="#职责链（责任链）模式" class="headerlink" title="职责链（责任链）模式"></a>职责链（责任链）模式</h4>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javap命令的说明</title>
      <link href="2020/11/07/javap%E5%91%BD%E4%BB%A4%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
      <url>2020/11/07/javap%E5%91%BD%E4%BB%A4%E7%9A%84%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-lazy-src="javap.png"></p><ul><li><code>-version:</code>当前javap所在jdk的版本信息</li><li><code>-public:</code>仅显示公共类和成员<span id="more"></span></li><li><code>-protected:</code>显示受保护的/公共类和成员</li><li><code>-p -private:</code>显示所有类和成员</li><li><code>-package:</code>显示程序包/受保护的/公共类和成员（默认）</li><li><code>-sysinfo:</code>显示正在处理的类的系统信息（路径、大小、日期、MD5、散列、源文件名）</li><li><code>-constants:</code>显示静态最终常量的具体值<ul><li>常量的初始化是在类加载的<strong>准备</strong>阶段。</li></ul></li></ul><ul><li><code>-s:</code>输出内部类型签名<ul><li>也就是描述符，包括：方法参数和返回值类型。</li></ul></li><li><code>-l:</code>输出行号和本地变量表<ul><li>行号和局部变量表是可有可无的，比如在编译的时候没有使用<code>-g</code>参数，就会没有这个结构。这个结构是用来帮助<code>debugger</code>的（*摘自 <code>jvms8</code>*）；</li></ul></li><li><code>-c:</code>对代码进行反汇编<ul><li>也就是输出方法的<code>code</code>属性</li></ul></li><li><code>-v -verbose:</code>输出附加信息（包括行号、本地变量表、反汇编等详细信息）</li></ul><p><strong>注意事项：</strong></p><ul><li>使用<code>javap</code>命令反解析会将<code>构造参数</code>还原成真实的名字。而自己解析或使用<code>jclaalib</code>插件看的时候，显示的是<code>init</code>方法。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>foreach循环中为什么不要进行remove/add操作</title>
      <link href="2020/11/07/foreach%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E8%BF%9B%E8%A1%8Cremove-add%E6%93%8D%E4%BD%9C/"/>
      <url>2020/11/07/foreach%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E8%BF%9B%E8%A1%8Cremove-add%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>昨天在看<a href="https://snailclimb.gitee.io/javaguide/#/">JavaGuide</a>的时候，发现了一个关于<code>foreach</code>循环的一个很有意思的问题。</p><p>众所周知，不建议在<code>forEach</code>循环中调用<code>add()/remove()</code>方法，阿里巴巴编程规范里面指明了这一点。那么是为什么呢？相信很多人心中会有这个疑问。</p><p>从下面三段代码来分析这个问题：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(s)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">                list.remove(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码的运行结果为：</p><p><img src= "/img/loading.gif" data-lazy-src="1.png"></p><p>一开始发现这个代码的时候我是觉得有点奇怪的，<code>foreach</code>简单的被编译器翻译为迭代器。</p><p>迭代器第一次返回的元素是1，<code>if</code>条件判断为真，所以删除第一个元素；</p><p>然后！！！！应该再次进入循环，打印一个<code>2</code>。接着跳出循环，遍历<code>list</code>元素，再打印一个<code>2</code>才对！</p><p>可是！！！分析实际运行结果来看，并没有进入第二次循环。这是为什么呢？</p><p>参考了一篇文章：[<a href="https://www.cnblogs.com/luyu1993/p/7148765.html]">https://www.cnblogs.com/luyu1993/p/7148765.html]</a></p><p>可以看到生成的<code>.class</code>文件为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Iterator var1 = list.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">            String s = (String)var1.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(s)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">                list.remove(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PrintStream var10001 = System.out;</span><br><span class="line">        list.forEach(var10001::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编译器确实将foreach循环翻译为了iterator迭代器。首先调用<code>iterator().hasNext()</code>方法判断有没有下一个元素。</p><p><strong>注意：</strong>这里的<code>list.iterator()</code>方法调用的是<code>ArrayList</code>内的方法，返回的是<code>ArrayList</code>的一个内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">       <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">       <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">       Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> cursor != size;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           checkForComodification();</span><br><span class="line">           <span class="keyword">int</span> i = cursor;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">           Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           cursor = i + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">           checkForComodification();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">               cursor = lastRet;</span><br><span class="line">               lastRet = -<span class="number">1</span>;</span><br><span class="line">               expectedModCount = modCount;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">           Objects.requireNonNull(consumer);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">           <span class="keyword">int</span> i = cursor;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">               consumer.accept((E) elementData[i++]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">           cursor = i;</span><br><span class="line">           lastRet = i - <span class="number">1</span>;</span><br><span class="line">           checkForComodification();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对这个内部类的理解：</p><p>内部定义了三个变量：<code>cursor,lastRet和expectedModCount</code>。</p><ul><li><code>cursor:</code>游标。当前迭代器所在的位置。在构造函数中没有进行显式初始化，因此初始化为0.</li><li><code>lastRet:</code>上一个返回的元素的索引。默认为-1.</li><li><code>exceptedModCount:</code>期待结构改变的次数。这个变量只有通过内部类的方法才能进行修改。初始时和<code>modcount</code>的大小相等。</li></ul><p>调用<code>hasNext()</code>方法时，首先比较<code>cursor</code>和<code>size</code>是否相等，如果相等，说明已经遍历完了，返回false；没有遍历完的话，则返回true;</p><p><code>next()</code>方法，则先比较<code>modcount</code>和<code>exceptedModCount</code>是否相等，如果不相等，则抛出<code>ConcurrentModificationException</code>。</p><hr><p>说了这么多，下面根据第一段代码总结一下：</p><p><code>list</code>增加两个元素之后，modcount=2;获得迭代器之后，exceptedModCount=modcount=2;</p><p>然后判断<code>var1.hasNext</code>是否成立。此时<code>cursor=0</code>,<code>size=2</code>,所以条件为真，进入循环。进入循环后调用<code>itr.next()</code>方法，此时<code>modCount=exceptedModCount=2</code>,然后<code>cursor</code>往前走一个，并且返回<code>(E)elementData[cursor] </code>(返回跨过的元素)。</p><p><code>&quot;1&quot;.equals(s)==true</code>，所以删除当前元素，注意这里删除元素用的是<code>ArrayList</code>里面的<code>remove(Object o)</code>方法，这个方法只会改变<code>modCount</code>的值，不会改变<code>exceptedModCount</code>的值。</p><p><strong>此处看一下<code>ArrayList</code>中的内部类<code>Itr</code>中重写的remove()方法：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>这个方法中同时改变了<code>modCount</code>和<code>exceptedModCount</code>的值，令二者相等。</strong></p><p>所以删除了第一个元素之后，<code>size=1,modCount=3,exceptedModCount=2,cursor=1</code>.此时进入第二次循环，<code>cursor==size==1</code>,<code>hasNext()</code>方法为<code>false</code>,所以不会再进行第二次循环。</p><hr><p>然后再看第二段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;2&quot;</span>.equals(s)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">                list.remove(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码相对第一段代码的改变是：<strong>将删除的判断条件由“1”改为了“2”，也就是要删除第二个元素。</strong>想一下，这里代码运行时会出现什么情况。</p><p>获得<code>iterator()</code>后，各个变量的值为：<code>modCount=2,exceptedModCount=modCount=2,cursor=0,size=2</code>.</p><p>第一次循环，什么也没做。第一次循环结束后，各个变量的值为：<code>modCount=2=exceptedModCount,size=2,cursor=1</code>;</p><p>然后进行第二次循环的判断，<code>hasNext()</code>中，<code>cursor!=size</code>,所以没到结束，进入第二次循环，调用<code>itr.next()</code>方法，调用结束后，<code>modCount=exceptedModCount=2,cursor=2,size=2</code>,并且返回的是<code>&quot;2&quot;</code>.</p><p>判断<code>&quot;2&quot;.equals(s)</code>,为真，所以删除第二个元素。<strong>注意：此时调用的是<code>ArrayList</code>中的remove(Object o)方法，modCount++,所以删除后，modCount=3.而exceptedModCount=2. size=1</strong></p><p>进行循环条件的判断，<code>haxNext()</code>方法中，<code>cursor!=size</code>为false,认为还没有遍历到结尾。所以再调用<code>next()</code>方法。<code>next()</code>方法中，首先调用<code>checkForModification()</code>方法，此时<code>modCount!=exceptedModCount</code>,抛出<code>ConcurrentModificationException</code>.</p><p>具体的运行结果为：</p><p><img src= "/img/loading.gif" data-lazy-src="2.png"></p><hr><p>再看第三段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(s)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">                list.remove(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简单分析一下：</p><p>初始时，<code>modCount=exceptedModCount=3,cursor=0,size=3</code></p><p>调用<code>list.remove(Object o)</code>方法，<code>modCount++,modCount=4,size=2,此外还有cursor=1</code>.</p><p>此时，进行第二次循环条件的判断，<code>hasNext()</code>方法中，<code>cursor=1,size=2</code>,所以没有遍历结束。进入第二次循环。第二次循环一开始，先调用<code>next()</code>方法。<code>next()</code>方法中，也是先调用<code>checkForComodification</code>方法，发现并发修改异常，抛出相应异常。</p><p>具体的运行效果为：</p><p><img src= "/img/loading.gif" data-lazy-src="3.png"></p><hr><p>因此，不要在<code>foreach</code>循环中调用<code>list的add/remove</code>方法。而应该调用迭代器的<code>remove</code>方法，<strong>迭代器中没有add()方法</strong>。看一下迭代器的<code>remove</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">           checkForComodification();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">               cursor = lastRet;</span><br><span class="line">               lastRet = -<span class="number">1</span>;</span><br><span class="line">               expectedModCount = modCount;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>在调用<code>ArrayList.remove(Integer index)</code>方法后，令<code>modCount=exceptedModCount</code>，所以不会出现上面说到的几种异常。</p><hr><p>关于集合中的迭代器，是集合上遍历元素的一种抽象。但是对于<code>Set</code>来说，元素之间是无序的。</p><p><strong>如果在迭代器中定义add()方法，类似于remove()方法，是将新的元素插入到当前位置（两个元素之间），而<code>Set</code>的元素之间是不存在位置关系的，所以无法定义add()方法。 在Iterator的子接口ListIterator中才提供了add(E element)方法</strong>。</p><p><code>ListIterator</code>接口中还有另外两个用来反向遍历的方法，<code>hasPrevious()和previous()</code>。用来获得索引的<code>previousIndex()和nextIndex()方法</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">       ListIterator&lt;String&gt; stringListIterator = list.listIterator(<span class="number">2</span>);</span><br><span class="line">       System.out.println(stringListIterator.previousIndex());</span><br><span class="line">       System.out.println(stringListIterator.nextIndex());</span><br><span class="line">       <span class="keyword">while</span>(stringListIterator.hasPrevious())&#123;</span><br><span class="line">           System.out.println(stringListIterator.previous());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="4.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2020/11/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/11/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="采用设计模式的目的"><a href="#采用设计模式的目的" class="headerlink" title="采用设计模式的目的"></a>采用设计模式的目的</h2><ol><li>代码重用性</li><li>可读性</li><li>可扩展性</li><li>可靠性</li><li>使程序呈现高内聚，低耦合的特性<span id="more"></span></li></ol><h2 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><ol><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转（倒置）原则</li><li>里氏替换原则</li><li>开闭原则</li><li>迪米特原则</li><li>合成复用原则</li></ol><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>对类来说的，即一个类应该只负责一项职责，如类<code>A</code>负责两个不同职责：职责1，职责2.</p><p>当职责1需求就更而改变<code>A</code>时，可能造成职责2执行错误，所以需要将类<code>A</code>的粒度分解为<code>A1</code>,<code>A2</code></p><h2 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h2><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><h2 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h2><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒转（倒置）的中心思想是面向接口编程</li><li>抽象倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在<code>Java</code>中，抽象指的是接口或抽象类，细节就是具体的实现类。</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</li></ol><h3 id="依赖关系传递的三种方式"><a href="#依赖关系传递的三种方式" class="headerlink" title="依赖关系传递的三种方式"></a>依赖关系传递的三种方式</h3><ol><li>接口传递</li><li>构造方法传递</li><li><code>setter</code>方式传递</li></ol><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p><code>OO</code>中的继承性的思考和说明</p><ol><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li><li>问题提出：在编程中，如何正确的使用继承？==》里氏替换原则</li></ol><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>如果对每个类型为<code>T1</code>的对象<code>o1</code>，都有类型为<code>T2</code>的对象<code>o2</code>，使得以<code>T1</code>定义的所有程序<code>P</code>在所有的对象 <code>o1</code>都代换成<code>o2</code>时，程序<code>p</code>的行为没有发生变化，那么类型<code>T2</code>是类型<code>T1</code>的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</p><p>在使用继承时，遵循里氏替换原则 ，在子类中尽量不要重写父类的方法</p><p>里氏替换原则告诉我们，继承实际上让两个耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。</p><h2 id="开闭原则（Open-Closed-Principle）"><a href="#开闭原则（Open-Closed-Principle）" class="headerlink" title="开闭原则（Open Closed Principle）"></a>开闭原则（Open Closed Principle）</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则</li><li>一个软件实体如类，模块和函数应该对扩展开放（提供方），对修改关闭（使用方）。用抽象构建框架，用实现扩展细节。</li><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过已有的代码来实现变化</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li></ol><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>一个对象应该对其它对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则（Demeter Principle）又叫<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封闭在类的内部。对外除了提供的<code>public</code>方法，不对外泄漏任何信息。</li><li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li><li><strong>直接的朋友：</strong>每个对象都会与其它对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li></ol><h3 id="迪米特法则注意事项和细节"><a href="#迪米特法则注意事项和细节" class="headerlink" title="迪米特法则注意事项和细节"></a>迪米特法则注意事项和细节</h3><ol><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：由于等比例类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系</li></ol><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>原则是尽量使用合成/聚合的方式 ，而不是使用继承</p><hr><h2 id="设计模式核心思想"><a href="#设计模式核心思想" class="headerlink" title="设计模式核心思想"></a>设计模式核心思想</h2><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</li><li>针对接口编程，而不是针对实现编程</li><li>为了交互对象之间的松耦合设计而努力</li></ol><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><p>依赖、泛化、组合、聚合、实现、关联</p><ol><li><p>依赖关系（Dependence）</p><p>只要是在类中用到了对方，那么它们之间就存在依赖关系。如果没有对方，编译都过不了。</p></li><li><p>泛化关系（Generalization）</p><p>泛化关系实际上就是继承关系，他是<strong>依赖关系的特例</strong></p></li><li><p>实现关系（Implementation）</p><p>实现关系实际上就是A类实现B接口，他是<strong>依赖关系的特例</strong></p></li><li><p>关联关系（Association）</p><p>关联关系实际上就是<strong>类与类之间的联系，他是依赖关系的特例</strong></p><p>关联具有<strong>导航性</strong>：即双向关系或单向关系</p><p>关系具有多重性</p></li><li><p>聚合关系（Aggregation）</p><p>聚合关系（Aggregation）表示的是整体和部分的关系，<strong>整体与部分是可以分开的。聚合关系是关联关系的特例，</strong>所以它具有关联的屏声导航性与多重性。</p></li><li><p>组合关系（Composition）</p><p>不可分离。也是整体与部分的关系，但是<strong>整体与部分不可分离。</strong></p></li></ol><hr><h2 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h2><p>设计模式分为三种类型，共23种。</p><ol><li><p>创建型模式</p><p><strong>单例模式</strong>、抽象工厂模式、原则模式、建造者模式、<strong>工厂模式</strong></p></li><li><p>结构型模式</p><p>适配器模式、桥接模式、<strong>装饰模式</strong>、组合模式、外观模式、享元模式、<strong>代理模式</strong></p></li><li><p>行为型模式</p><p>模板方法模式、命令模式、访问者模式、迭代器模式、<strong>观察者模式</strong>、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）</p></li></ol><hr><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>所谓类的单例设计模式，就是采取一定的方法，保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个获取其对象实例的方法（一般是静态的）。</p><h3 id="单例模式有八种方式"><a href="#单例模式有八种方式" class="headerlink" title="单例模式有八种方式"></a>单例模式有八种方式</h3><ol><li><p>饿汉式（静态常量）</p><ol><li><p>构造器私有化（防止new）</p></li><li><p>类的内部创建对象</p></li><li><p>向外暴露一个静态的公共方法。<code>getInstance</code></p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优缺点问题</p><ol><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</li><li>缺点：在类装载的时候就完成实例化，没有达到<code>Lazy Loading</code>的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</li><li>这种方式基于<code>classloader</code>机制避免了多线程的同步问题。不过，<code>instance</code>在类装载时就实例化，在单例模式中大多数都是调用<code>getInstance</code>方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类的装载，这时候初始化<code>instance</code>就没有达到<code>lagy loading</code>的效果。</li><li>结论：这种单例模式可用，<strong>可能</strong>造成内存浪费</li></ol></li></ol></li><li><p>饿汉式（静态代码块）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//在静态代码块中创建单例对象</span></span><br><span class="line">        instance=<span class="keyword">new</span> Singleton2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><ol><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li><li>结论：这种单例模式可用，但是可能会造成内存浪费。</li></ol></li><li><p>懒汉式（线程不安全）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> Singleton3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>优缺点说明：<ol><li>起到了<code>Lazy loading</code>的效果，但是只能在单线程下使用</li><li>如果在多线程下，一个线程进入了<code>if(instance == null)</code>判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li><li>结论：在实际开发中，不要使用这种方式</li></ol></li></ol></li><li><p>懒汉式（线程安全，同步方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>优缺点说明<ol><li>解决了线程不安全问题</li><li>效率太低了，每个线程在想获得类的实例的时候，执行<code>getInstance()</code>方法都要进行同步。面其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接<code>return</code>就行了。方法进行同步效率太低。</li><li>结论：在实际开发中，不推荐使用这种方式</li></ol></li></ol></li><li><p>懒汉式（线程安全，同步代码块）</p></li><li><p>双重检查</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton6 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton6.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton6();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>优缺点说明：<ol><li><code>Double-Check</code>概念是多线程开发中常使用到的，如代码中所示，我们进行了再次<code>if(singleton == null)</code>检查，这样就可以保证线程安全了</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断<code>if(singleton == null)</code>，直接<code>return</code>实例化对象，也避免了反复进行方法同步。</li><li>线程安全：延迟加载；效率较高</li><li>结论：在实际开发中，推荐使用这种单例设计模式</li></ol></li></ol></li><li><p>静态内部类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用静态内部类完成单例设计模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton7</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton7</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton7 INSTANCE = <span class="keyword">new</span> Singleton7();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>优缺点说明：<ol><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程</li><li>静态内部类方式在<code>Singleton</code>类被装载时并不会立即实例化，而是在需要实例化时，调用<code>getInstance</code>方法，才会装载<code>SingletonInstance</code>类，从而完成<code>Singleton</code>的实例化</li><li>类的静态属性只会在第一次加载类的时候进行初始化，所以在这里，<code>JVM</code>帮助我们实现了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li><li>优点：避免了<code>线程</code>不安全，利用静态内部类特点实现懒加载，效率高</li><li>结论：推荐使用</li></ol></li></ol></li><li><p>枚举</p><ol><li>这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且不能防止反序列化重新创建新的对象</li><li>这种方式是<code>Effective Java</code>作者<code>Josh Bloch</code>提倡的方式</li><li>结论：推荐使用</li></ol></li></ol><hr><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品的实例。简单工厂模式是工厂模式家族中最简单实用的模式</li><li>简单工厂模式：定义了一个创建对象的类，由这个类来封闭实例化对象的行为（代码）。</li><li>在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。</li></ol><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>定义了一个<code>interface</code>用于创建相关或有依赖关系的对象簇，而无须指明具体的类</li><li>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合</li><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）。</li><li>将工厂抽象成两层，<code>AbsFactory</code>(抽象工厂)和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</li></ol><h2 id="工厂模式小结"><a href="#工厂模式小结" class="headerlink" title="工厂模式小结"></a>工厂模式小结</h2><ol><li>工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</li><li>三种工厂模式</li><li>设计模式的依赖抽象原则</li></ol><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>原型模式（<code>Prototype</code>）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li><li>原型模式是一种创建开设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li><li>工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们来实施创建，即 对象.<code>clone()</code></li><li>形象的理解：孙大圣拔出猴毛，变出其它孙大圣</li></ol><h3 id="原型模式的注意事项和细节"><a href="#原型模式的注意事项和细节" class="headerlink" title="原型模式的注意事项和细节"></a>原型模式的注意事项和细节</h3><ol><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态</li><li>如果原始对象发生变化（增加或者减少属性），其它克隆对象也会发生相应的变化，无需修改代码</li><li>在实现深克隆的时候可能需要比较复杂的代码</li><li>缺点：需要为第一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了<code>OCP</code>原则。</li></ol><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>建造者模式（<code>Builder Pattern</code>）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象</li><li>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部具体构建细节</li></ol><h3 id="建造者模式的四个角色"><a href="#建造者模式的四个角色" class="headerlink" title="建造者模式的四个角色"></a>建造者模式的四个角色</h3><ol><li><code>Product</code>(产品角色)：一个具体的产品对象</li><li><code>Builder</code>(抽象建造者)：创建一个<code>Product</code>对象的各个部件指定的接口/抽象类</li><li><code>ConcreteBuilder</code>(具体建造者)：实现接口，构建和装配各个部件</li><li><code>Director</code>(指挥者)：构建一个使用<code>Builder</code>接口的对象。它主要是 用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程</li></ol><h3 id="建造者模式在StringBuilder中的使用"><a href="#建造者模式在StringBuilder中的使用" class="headerlink" title="建造者模式在StringBuilder中的使用"></a>建造者模式在<code>StringBuilder</code>中的使用</h3><p>角色分析：</p><ol><li><code>Appendable</code>接口定义了多个<code>append()</code>方法（抽象方法），即<code>Appendable</code>为抽象建造者，定义了抽象方法</li><li><code>AbstractStringBuilder</code>实现了<code>Appendable</code>接口方法，这里的<code>AbstractStringBuilder</code>已经是建造者，只是不能实例化</li><li><code>StringBuilder</code>既充当了建造者，也充当了指挥者。建造方法的实现是由<code>AbstractStringBuilder</code>完成，而<code>StringBuilder</code>继承了<code>AbstractStringBuilder</code></li></ol><h3 id="建造者模式的注意事项和细节"><a href="#建造者模式的注意事项和细节" class="headerlink" title="建造者模式的注意事项和细节"></a>建造者模式的注意事项和细节</h3><ol><li><p>客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</p></li><li><p>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象</p></li><li><p>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</p></li><li><p>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”</p></li><li><p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<strong>如果产品之间的差异性很大，则不适合使用建造者模式</strong>，因此其使用范围受到一定的限制。</p></li><li><p>如果产品的变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致变得很庞大，因此在这种情况下，要考虑是否选择建造者模式</p></li><li><p><strong>抽象工厂模式VS建造者模式</strong></p><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</p></li></ol><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>适配器模式（<code>Adapter Pattern</code>）将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器（<code>Wrapper</code>）</li><li>适配器模式属于结构型模式</li><li>主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>适配器模式：将一个类的接口转换成另一种接口。让<strong>原本接口不兼容的类可以兼容</strong></li><li>从用户的角度看不到被适配者，是解耦的</li><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>用户收到反馈结果，感觉只是和目标接口交互</li></ol><h3 id="类适配器模式注意事项和细节"><a href="#类适配器模式注意事项和细节" class="headerlink" title="类适配器模式注意事项和细节"></a>类适配器模式注意事项和细节</h3><ol><li><code>Java</code>是单继承机制，所以类适配器需要继承<code>src</code>类这一点算是一个缺点，因为这要求<code>dst</code>必须是接口，有一定局限性</li><li><code>src</code>类的方法在<code>Adapter</code>中都会暴露出来，也增加了使用的成本</li><li>由于其继承了<code>src</code>类，所以它可以根据需求重写<code>src</code>类的方法，使得<code>Adapter</code>的灵活性增强了</li></ol><h3 id="对象适配器模式介绍"><a href="#对象适配器模式介绍" class="headerlink" title="对象适配器模式介绍"></a>对象适配器模式介绍</h3><ol><li>基本思路和类的适配器模式相同。只是将<code>Adapter</code>类作修改，不是继承<code>src</code>类，而是持有<code>src</code>类的实例，以解决兼容性的问题。即：持有<code>src</code>类，实现<code>dst</code>类接口，完成<code>src-&gt;dst</code>的适配</li><li>根据“合成复用原则“，在系统尽量使用关联关系来替代继承关系</li><li><strong>对象适配器模式是适配器模式常用的一种</strong></li></ol><h3 id="对象适配器模式注意事项和细节"><a href="#对象适配器模式注意事项和细节" class="headerlink" title="对象适配器模式注意事项和细节"></a>对象适配器模式注意事项和细节</h3><ol><li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承<code>src</code>的局限性问题，也不再要求<code>dst</code>必须是接口</li><li>使用成本更低，更灵活</li></ol><h3 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h3><ol><li>一些书籍称为：适配器模式(<code>Default Adapter Pattern</code>)或缺省适配器模式</li><li>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</li><li>适用于一个接口不想使用其所有的方法的情况</li></ol><h3 id="适配器模式的注意事项和细节"><a href="#适配器模式的注意事项和细节" class="headerlink" title="适配器模式的注意事项和细节"></a>适配器模式的注意事项和细节</h3><ol><li><p>三种命名方式：是根据<code>src</code>是以怎样的形式给到<code>Adapter</code>(在<code>Adapter</code>是的形式)来命名的。</p></li><li><p>类适配器：以类给到，在<code>Adapter</code>里，就是将<code>src</code>当做类，继承</p><p>对象适配器：以对象给到，在<code>Adapter</code>里，将<code>src</code>作为一个对象，持有</p><p>接口适配器：以接口给到，在<code>Adapter</code>里，将<code>src</code>作为一个接口，实现</p></li><li><p><code>Adapter</code>模式最大的作用还是将原本不兼容的接口融合在一起工作</p></li><li><p>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</p></li></ol><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>桥接模式(<code>Bridge</code>模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变</li><li>是一种结构型设计模式</li><li><code>Bridge</code>模式基于<strong>类的最小设计原则</strong>，通过使用封闭、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（<code>Abstraction</code>）与行为实现（<code>Implementation</code>）分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</li></ol><h3 id="类图说明"><a href="#类图说明" class="headerlink" title="类图说明"></a>类图说明</h3><ol><li><code>Client</code>类：桥接模式的调用者</li><li>抽象类（<code>Abstraction</code>）:维护了<code>Implementator</code>,即它的实现类<code>ConcreteImplementorA...</code>，二者是聚合关系，<code>Abstraction</code>充当桥接类</li><li><code>RefinedAbstraction</code>:是<code>Abstraction</code>抽象类的子类</li><li><code>Implementor</code>:行为实现类的接口</li><li><code>ConcreteImplementorA/B</code>:行为的具体实现类</li><li>从<code>UML</code>图：这里的抽象类各接口是聚合的关系，其实调用和被调用的关系</li></ol><h3 id="桥接模式的注意事项和细节"><a href="#桥接模式的注意事项和细节" class="headerlink" title="桥接模式的注意事项和细节"></a>桥接模式的注意事项和细节</h3><ol><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体的业务来完成</li><li>桥接模式替代多层继承方案，可以减少个数，降低系统的管理和成本</li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。</li></ol><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h3 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>装饰者模式：动态的将新功能附加到对象上。在对象扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(<code>ocp</code>)</li><li>这里提到的的将新附加到对象 和<code>ocp</code>原则，在后面的应用实例上会以代码的形式体现。</li></ol><h3 id="装饰者模式在JDK-IO流中的应用"><a href="#装饰者模式在JDK-IO流中的应用" class="headerlink" title="装饰者模式在JDK IO流中的应用"></a>装饰者模式在<code>JDK</code> <code>IO</code>流中的应用</h3><ol><li><code>InputStream</code>:是抽象类，类似前面的<code>Drink</code></li><li><code>FileInputStream</code>：是<code>InputStream</code>的子类，类似前面的<code>DeCaf</code>、<code>LongBlack</code></li><li><code>FilterInputStream</code>:是<code>InputStream</code>的子类，类似前面的<code>Decorator</code>修饰者</li><li><code>DataInputStream</code>:是<code>FilterInputStream</code>的子类，类似前面的<code>Milk</code>、<code>Soy</code>、<code>Chocolate</code>等</li><li><code>FilterInputStream</code>:含有<code>protected volatile InputStream in;</code>即含有被修饰者</li></ol><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>组合模式(<code>Composite Pattern</code>)，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树结构以表示”整体-部分“的层次关系</li><li>组合模式依据树形结构来组合对象，用来表示部分以及整体层次</li><li>这种类型的设计模式属于结构型模式</li><li>组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象</li></ol><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li><code>Component</code>:这是组合中的对象声明接口，在适当情况下，实现所有类共有的接口默认行为，用于访问和管理<code>Component</code>子部件，<code>Component</code>可以是抽象类或者接口</li><li><code>Leaf</code>:在组合中表示叶子节点，叶子节点没有子节点。</li><li><code>Composite</code>:非叶子节点，用于存储子部件，在<code>Component</code>接口中实现子部件的相关操作，比如增加，删除</li></ol><h3 id="组合模式在JDK-HashMap中的使用"><a href="#组合模式在JDK-HashMap中的使用" class="headerlink" title="组合模式在JDK``HashMap中的使用"></a>组合模式在<code>JDK``HashMap</code>中的使用</h3><ol><li><code>Map</code>就是一个抽象的构建（类似<code>Component</code>）</li><li><code>HashMap</code>是一个中间的构建(<code>Composite</code>),实现/继承了相关方法</li><li><code>Node</code>是<code>HashMap</code>的静态内部类，类似<code>Leaf</code>叶子节点，这里就没有<code>put,putall</code>方法</li></ol><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>外观模式（<code>facade</code>），也叫“过程模式”：外观模式为子系统中的一组接口提供了一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li><li>外观模式通过定义一个一致的接口，用心屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无须关心这个子系统的内部细节</li></ol><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ol><li>外观类（<code>Facade</code>）:为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求，从而将调用端的请求代理给子系统对象 </li><li>调用者（<code>Client</code>）:外观接口的调用者</li><li>子系统的集合：指模块或者子系统，处理<code>Facade</code>对象指派的任务，他是功能的实际提供者</li></ol><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>享元模式（<code>Flyweight Pattern</code>）也叫 蝇量模式：运用共享技术有效地支持大量细粒度的对象</li><li>学用于系统底层开发，解决系统的性能问题。像<strong>数据库连接池</strong>，里面都是创建好的连接对象，在这些连接对象中有我们需要的，则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</li><li>享元模式能够解决<strong>重复对象的内存浪费的问题</strong>，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</li><li>享元模式<strong>经典的应用场景</strong>就是池技术了，<code>String</code>常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</li></ol><h3 id="角色说明"><a href="#角色说明" class="headerlink" title="角色说明"></a>角色说明</h3><ol><li><code>FlyWeight</code>:抽象的享元角色，他是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或者实现</li><li><code>ConcreteFlyWeight</code>:是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</li><li><code>UnSharedConcreteFlyWeight</code>:是不可共享的角色，一般不会出现在享元工厂</li><li><code>FlyWeightFactory</code>:享元工厂类，用于构建一个池容器（集合），同时提供从池中获取对象方法</li></ol><h3 id="享元模式在JDK-Integer中的使用"><a href="#享元模式在JDK-Integer中的使用" class="headerlink" title="享元模式在JDK Integer中的使用"></a>享元模式在<code>JDK</code> <code>Integer</code>中的使用</h3><ol><li>在<code>valueOf</code>方法中，先判断是否在<code>IntegerCache</code>中，如果不在，就创建新的<code>Integer</code>(<code>new</code>)；否则，就直接从缓存池中返回</li><li><code>valueOf()</code>方法，就使用到了享元模式</li></ol><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>代理模式：为一个对象<strong>提供一个替身</strong>，以控制这个对象的访问。即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能</li><li>被代理对象可以是<strong>远程对象</strong>，创建开销大的对象或需要安全控制的对象</li><li>代理模式有不同的形式，主要有三种：<strong>静态代理，动态代理（<code>JDK</code>代理、接口代理）和<code>Cglib</code>代理（可以在内存动态的创建对象，而不需要实现接口，他是属于动态代理的范畴）</strong></li></ol><h3 id="静态代理模式的基本介绍"><a href="#静态代理模式的基本介绍" class="headerlink" title="静态代理模式的基本介绍"></a>静态代理模式的基本介绍</h3><p>静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同父类</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>模板方法模式（<code>Template Method Pattern</code>）,又叫模板模式（<code>Template Pattern</code>），在一个抽象类公开定义了执行它的方法的模板。它的子类按需要重写方法实现，但调用将以抽象类中定义的方式进行</li><li>简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</li><li>这种类型的设计模式属于行为型模式</li></ol><h3 id="角色说明-1"><a href="#角色说明-1" class="headerlink" title="角色说明"></a>角色说明</h3><ol><li><code>AbstractClass</code>抽象类，类中实现了模板方法，定义了算法的骨架，具体子类需要去实现其它的抽象方法<code>operation2,3,4</code></li><li><code>ConcreteClass</code>实现抽象方法<code>operation2,3,4</code>,以完成算法中特定子类的步骤</li></ol><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="基本介绍-17"><a href="#基本介绍-17" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li><p>命令模式（<code>Command Pattern</code>）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个。我们只需在程序者指定具体的请求接收者即可，此时，可以使用命令模式来进行设计</p></li><li><p>命名模式使得请求者与请求接收者消除彼此之间的耦合，音质调用关系更加灵活，实现解耦。</p></li><li><p>在命令模式中，会将一个请求封装为一个 对象 ，以便使用不同参数来表示不同的请求（即命名），同时命令模式也支持可撤消的操作</p></li><li><p>通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令（连接将军和士兵）</p><p><code>Invoker</code>是调用者（将军），<code>Receiver</code>是被调用者（士兵），<code>MyCommand</code>是命令，实现了<code>Command</code>接口，持有接收对象</p></li></ol><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="基本介绍-18"><a href="#基本介绍-18" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>访问者模式（<code>Visitor Pattern</code>），封闭一些作用于某种结构的各元素的操作，它可以在不改变数据的前提下定义作用于这些元素的新的操作</li><li>主要将数据结构与数据操作分离，解决<strong>数据结构</strong>和<strong>操作耦合性问题</strong></li><li>访问者模式的基本工作原理是：在被访问的类里面加一个对外提供待访问者的接口</li><li>访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联），同时需要避免让这些操作“污染”这些对象的类，可以选用访问者解决</li></ol><h3 id="角色说明-2"><a href="#角色说明-2" class="headerlink" title="角色说明"></a>角色说明</h3><ol><li><code>Visitor</code>是抽象访问者，为该对象结构中的<code>ConcreteElement</code>的第一个类声明一个<code>visit</code>操作</li><li><code>ConcreteVisitor</code>:是一个具体的访问者，实现每个有由<code>Visitor</code>声明的操作，是每个操作实现的部分</li><li><code>ObjectStructure</code>:能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问元素</li><li><code>Element</code>定义了一个<code>accept</code>方法，接收一个访问者对象</li><li><code>ConcreteElement</code>为具体元素，实现了<code>accept</code>方法</li></ol><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="基本介绍-19"><a href="#基本介绍-19" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>迭代器模式（<code>Iterator Pattern</code>）是常用的设计模式，属于行为型设计模式</li><li>如果我们的集合元素是用不同的方式实现的，有数组，还有<code>Java</code>的集合类，或者还有其他方式，当客户端要遍历这些元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代嚣模式解决。</li><li>迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露内部的结构。</li></ol><h3 id="角色说明-3"><a href="#角色说明-3" class="headerlink" title="角色说明"></a>角色说明</h3><ol><li><code>Iterator</code>：迭代器接口，是系统提供，含有<code>haxNext,next,remove</code></li><li><code>ConcreteIterator:</code>具体的迭代器类，管理迭代</li><li><code>Aggregate</code>:一个统一的聚合接口，将客户端和具体聚合解耦</li><li><code>ConcreteAggregate:</code>具体的聚合持有对象集合，并提供一个方法，返回一个迭代器，该迭代嚣可以正确遍历集合</li></ol><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="基本介绍-20"><a href="#基本介绍-20" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="基本介绍-21"><a href="#基本介绍-21" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>中介者模式(<code>Mediator Pattern</code>),用一个中介对象来封装一系列的对象交互.中介者使各个对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变他们之间的交互</li><li>中介者模式属于行为型模式,使代码易于维护</li><li>比如``MVC<code>模式,</code>C<code>(</code>Controller控制器<code>)是</code>M<code>(</code>Model<code>模型)和</code>V<code>(</code>View`视图)的中介者,在前后端交互时起到了中间人的作用</li></ol><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="基本介绍-22"><a href="#基本介绍-22" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>备忘录模式（<code>Memento Pattern</code>）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</li><li>可以这样理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个的某种状态，或者某些数据，当要做回退时，可以从备忘录忍者龟里获取振亚的数据进行恢复操作</li><li>备忘录模式属于行为型模式</li></ol><h3 id="角色分析"><a href="#角色分析" class="headerlink" title="角色分析"></a>角色分析</h3><ol><li><code>originator</code>:对象（需要保存状态的对象）</li><li><code>Menmento</code>:备忘录对象，负责保存好记录，即<code>originator</code>内部状态</li><li><code>Caretaker</code>:守护者对象，负责保存多个备忘录对象，使用集合管理，提高效率</li></ol><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="基本介绍-23"><a href="#基本介绍-23" class="headerlink" title="基本介绍"></a>基本介绍</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记22周岁生日</title>
      <link href="2020/11/03/%E8%AE%B022%E5%91%A8%E5%B2%81%E7%94%9F%E6%97%A5/"/>
      <url>2020/11/03/%E8%AE%B022%E5%91%A8%E5%B2%81%E7%94%9F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<p>​    22周岁的生日，平平淡淡，其实已经过去一段时间了。</p><span id="more"></span><p>​    今天有幸收到来自远方同学的礼物，原来就是她前几天提到过的保温杯……有点意外，这个保温杯竟然是给我的……</p><p>​    <strong>感谢今年的唯一一份礼物！</strong></p><p>​    好了，就到这里了……</p><p>​    放几张图……</p><p>​    <img src= "/img/loading.gif" data-lazy-src="1.jpg"></p><p>​    <img src= "/img/loading.gif" data-lazy-src="2.jpg"></p><hr><p>​    咳咳，在北京咳嗽拿了点药花了100多……在外面买药总是很贵……</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理合集</title>
      <link href="2020/11/02/%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86/"/>
      <url>2020/11/02/%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h2><ol><li>Random类</li></ol><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li>String为什么不可变？<ul><li><p>简单来说，String底层的存储结构为<code>private final char[] value;</code>数组，JDK9之后改为了<code>private final byte[] value</code>，设计思想就是不让String可变，String内部的方法，比如concat拼接方法，replace()替换字符的方法，最后都返回了新的String对象。所以说String是不可变的。</p><span id="more"></span></li></ul></li><li>StringBuilder和StringBuffer的区别？<ul><li>StringBuilder和StringBuffer都继承自AbstractStringBuilder,在源码中：AbstractStringBuilder实现了Appendable和CharSequence方法，具体的存储结构是<code>char[] value</code>数组，并且定义了一个数组的最大值为<code>Integer.MAX_VALUE-8</code>，不管是在初始化还是扩容过程中超过这个容量都会抛出异常。</li><li>扩容过程：<ul><li>先调用<code>ensureCapacity(minCapacity)</code>方法，如果minCapacity是负数，则改方法没有任何作用，只会简单的返回。</li><li>如果是正数，则继续调用<code>ensureCapacityInternal（）</code>的<code>private</code>方法，在该方法中调用<code>Arrays.copyOf()</code>方法实现真正的扩容。</li><li><code>Arrays.copyOf()</code>方法中调用<code>newCapacity</code>方法，扩容后的容量为原来的<code>value.length</code>+2和需要的容量的最小值。</li><li>如果扩容的容量太大，超过了规定的最大值，也就是<code>Integer.MAX_VALUE-8</code>，则比较需要的容量<code>minCapacity</code>和最大值的大小，如果minCapacity超过Integer.MAX_VALUE的值，则直接抛出<code>OutOfMemory</code>异常。否则返回minCapacity和规定最大值的较大值。</li></ul></li><li>StringBuffer：since jdk1.0。所有的方法都有同步效果，或者是加了同步关键字，或者是通过方法之间的相互调用达到了同步的效果。</li><li>StringBuilder:since jdk1.5。没有同步效果，效率高于StringBuffer.</li><li>默认创建的数组大小都是16或者原来的大小加16.</li></ul></li><li>在以下4种情况下，finally块不会被执行：<ol><li>在finally语句块第一行发生了异常。（因为在其它行，finally块还是会等到执行）</li><li>在前面的代码中用了System.exit(int)已退出程序。exit()是带参函数；若该语句在异常语句之后，finally块会执行</li><li>程序所在的线程死亡</li><li>关闭CPU</li></ol></li></ul><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><ul><li><p><strong>数据</strong>：信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合</p></li><li><p><strong>数据对象</strong>：具有相同性质的数据元素的集合，是数据的一个子集。</p></li><li><p><strong>数据元素</strong>：数据的基本单位，通常作为一个整体进行考虑和处理</p></li><li><p><strong>数据项</strong>：构成数据元素的不可分割的最小单位。</p></li><li><p><strong>循环队列</strong>：关键是<strong>取余(%MaxSize)</strong></p><p>front指针移动：<code>Q.front = (Q.front+1)%MaxSize</code></p><p>rear指针移动：<code>Q.rear = (Q.rear+1)%MaxSize</code></p><p>队列长度：<code>(Q.rear-Q.front+MaxSize)%Maxsize</code></p><p>队空条件：<code>Q.front==Q.rear</code></p><p>队满条件：<code>Q.front==Q.rear</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><ul><li>方法1：牺牲一个存储单元： 少存放一个元素；判断队满：<code>Q.front==(Q.rear+1)%MaxSize</code></li><li>方法2：增加一个计数变量</li><li>方法3：增加tag标识（队空是由于出队引起的，队满是由于入队引起的）；队空条件：<code>Q.front==Q.rear&amp;&amp;tag==0</code>；队满条件：<code>Q.front==Q.rear&amp;&amp;tag==1</code></li></ul></li><li><p>栈的出栈序列个数：<br>$$<br>f(n)=\frac{n+1}{C_{2n}^n}<br>$$<br>递推公式：<br>$$<br>f(k)=f(k-1)+f(n-k)<br>$$</p></li><li><p>栈的应用：</p><ol><li>括号匹配：<ol><li>初始一个空栈，顺序读入括号</li><li>若是右括号，则与栈顶元素进行匹配<ol><li>若匹配，则弹出栈底元素并进行下一个元素</li><li>若不匹配，则该序列不合法</li></ol></li><li>若是左括号，则压入栈中</li><li>若全部元素遍历完毕，栈中非空则序列不合法</li></ol></li><li>表达式求值：</li><li>中缀转前缀：  </li><li>中缀转后缀：<ol><li>数字直接加入后缀表达式</li><li>运算符时：<ol><li>若为“（”，入栈</li><li>若为“）”，则依次把栈中的运算符加入后缀表达式，直到出现“（”，并从栈中删除“（”</li></ol></li><li>若为+，-，*，/，<ol><li>栈空，入栈</li><li>栈顶元素为“（”，入栈</li><li>高于栈顶元素优先级，入栈</li><li>否则，依次弹出栈顶运算符，直到一个优先级比它低的运算符或“（”为止</li></ol></li><li>遍历完成，若栈非空依次弹出所有元素</li></ol></li></ol></li><li><p><strong>矩阵的压缩存储</strong></p><ul><li><p><strong>压缩存储</strong>：指多个值相同的元素只分配一个存储空间，对零元素不分配存储空间</p></li><li><p><strong>特殊矩阵</strong>：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布具有一定的规律性</p></li><li><p><strong>特殊矩阵的压缩存储</strong>：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布、值相同的多个矩阵元素压缩存储到一个存储空间上</p></li><li><p>三对角矩阵的数组下标：<br>$$<br>3*(i-1)-1+(j-i)+1+1-1<br>$$<br>化简后为：<br>$$<br>2i+j-3<br>$$<br>若k已知，求i,j?<br>$$<br>i= \left\lfloor (k+1)/3+1\right\rfloor<br>$$</p><p>$$<br>j=k+3-2i<br>$$</p></li></ul></li><li><p><strong>稀疏矩阵</strong>：矩阵元素个数S相对于矩阵中非零元素的个数T来说非常多，即S&gt;&gt;t的矩阵称为稀疏矩阵</p></li><li><p><strong>三元组</strong>：(行标，列标，值)</p></li><li><p><strong>树的度</strong>：树中最大度数称为树的度</p></li><li><p><strong>度数为2的树与二叉树的区别：</strong></p><ul><li>度数为2的树最少有3个节点 二叉树可以有0个节点</li><li>度数为2的有序树的孩子节点的左右是相对的</li></ul></li><li><p><strong>满二叉树</strong>：每一层的满</p></li><li><p><strong>完全二叉树</strong>：前一层是满二叉树</p></li><li><p><strong>二叉排序树</strong>：左子树节点的关键字均小于根节点，右子树节点均大于根节点</p></li><li><p><strong>平衡二叉树</strong>：左子树和右子树的深度之差不超过1</p></li><li><p><strong>中序遍历非递归算法</strong>：</p><ul><li>初始时，依次扫描根节点的所有左侧节点并将它们一一进栈</li><li>出栈一个节点，访问它</li><li>扫描该节点的右孩子节点并将其进栈</li><li>依次扫描右孩子节点的所有左侧节点并一一进栈</li><li>反复该过程直到栈空为止</li></ul></li><li><p><strong>二叉树的层次遍历：</strong></p><ul><li>初始时将根入队并访问根节点，然后出队</li><li>若有左子树，则将左子树的根入队</li><li>若有右子树，则将右子树的根入队</li><li>然后出队，访问该节点</li><li>反复该过程直到队列空为止</li></ul></li><li><p><strong>树的线索化</strong>：（线索链表、线索二叉树）</p><ul><li>若无左子树，则将左指针指向其前驱节点</li><li>若无右子树，则将右指针指向其后继节点</li></ul></li></ul><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ul><li>双亲表示法：采用一组连续的存储空间来存储每个节点，同时在每个节点中增设一个伪指针，指示双亲节点在数组中的位置。根节点的下标为0，其伪指针域为-1。</li><li>孩子表示法：将每个节点的孩子节点都用单链表连接起来形成一个线性结构，n个孩子具有n个孩子链表。</li><li>孩子兄弟表示法：以二叉链表作为树的存储结构，又称二叉树表示法。<strong>（左孩子右兄弟表示法）</strong> （节点第一个孩子的节点指针，节点值，节点下一个兄弟节点指针）</li></ul><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>无中序遍历</p><p>树的先根遍历序列和二叉树的先根遍历序列相同。</p><p>树的后根遍历序列和二叉树的中根遍历序列相同。</p><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><p> 先序和中序遍历</p><p>森林的中序遍历序列与森林对应二叉树的中序遍历序列相同</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>一种简单的集合表示。</p><p>通常用树的双亲表示法作为并查集的存储结构。</p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>二叉排序树的中序遍历序列是一个递增的有序序列</p><p><strong>二叉排序树的删除</strong>：</p><p>用中序序列的直接后继代替被删除节点</p><h3 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h3><p>高度为h的最小平衡二叉树的节点数$N_h$</p><p>递推公式：$N_h=N_{h-1}+N_{h-2}+1 （N_0=0,N_1=1）$</p><p>平衡二叉树的判断：利用递归的后序遍历。</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>树的带权路径长度：$WPL=\sum_{i=0}^{n}w_il_i$</p><p><strong>哈夫曼树</strong>：也称最优二叉树，含有N个带权叶子节点带权路径长度最小的二叉树</p><p>n个叶子节点的哈夫曼树的节点总数为2n-1,度为2的节点数为n-1。</p><p><strong>前缀编码：</strong>没有一个编码是另一个编码的前缀</p><p><em>哈夫曼树并不唯一，所以每个字符对应的哈夫曼编码也不唯一，但带权路径长度相同且最优</em></p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h4><ol><li>邻接矩阵法（空间复杂度为$O(n^2)$）,适用于稠密图</li><li>设图G的邻接矩阵为A，矩阵运算$A^n$的含义：$A^n[i][j]$表示从顶点$v_i$到顶点$v_j$的长度为n的路径条数</li><li>邻接表法<ol><li>为每个顶点建立一个单链表存放与它相邻的边</li><li>适用于稀疏图</li></ol></li><li>十字链表<ol><li><strong>有向图</strong>的一种<strong>链式</strong>存储结构</li><li>边表+顶点表</li><li>十字链表例子：<img src= "/img/loading.gif" data-lazy-src="%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E4%BE%8B%E5%AD%90.png"></li></ol></li><li>邻接多重表<ol><li><strong>无向图</strong>的一种<strong>链式</strong>存储结构</li><li>邻接多重表例子：<img src= "/img/loading.gif" data-lazy-src="%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E4%BE%8B%E5%AD%90.png"></li></ol></li></ol><h3 id="图的广度优先搜索"><a href="#图的广度优先搜索" class="headerlink" title="图的广度优先搜索"></a>图的广度优先搜索</h3><p>代码：<img src= "/img/loading.gif" data-lazy-src="%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.png"></p><p><strong>应用：</strong>可以利用图的广度优先搜索求无权图单源最短路径问题。</p><h4 id="无权图单源最短路径问题"><a href="#无权图单源最短路径问题" class="headerlink" title="无权图单源最短路径问题"></a>无权图单源最短路径问题</h4><p><img src= "/img/loading.gif" data-lazy-src="%E6%97%A0%E6%9D%83%E5%9B%BE%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.png"></p><h3 id="图的深度优先搜索"><a href="#图的深度优先搜索" class="headerlink" title="图的深度优先搜索"></a>图的深度优先搜索</h3><p><img src= "/img/loading.gif" data-lazy-src="%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.png"></p><h4 id="遍历与连通性问题"><a href="#遍历与连通性问题" class="headerlink" title="遍历与连通性问题"></a>遍历与连通性问题</h4><p>在无向图中，在任意节点出发进行一次遍历（调用一次BFS或DFS），若能访问全部节点，说明该无向图是连通的。</p><p>在无向图中，调用遍历函数的次数为连通分量的个数。</p><p><strong>以上两个结论只适用于无向图，在有向图中都不成立。</strong></p><h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>生成树：连通图包含全部顶点的一个极小连通子图</p><p>对于带权的无向联通图$G=(V,E),G$的所有生成树当中边的权值最小的生成树为G的最小生成树(MST)。</p><p><code>Prim</code>算法：（贪心算法）</p><p><img src= "/img/loading.gif" data-lazy-src="Prim%E7%AE%97%E6%B3%95.png"></p><p>该算法的时间复杂度为$O(|V|^2)$，因此适用于稠密图</p><p>克鲁斯卡尔算法：</p><p><img src= "/img/loading.gif" data-lazy-src="%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94.png"></p><p>时间复杂度为$O(|E|log|E|)$,所以更加适用于稀疏图。</p><h3 id="单源最短路径问题"><a href="#单源最短路径问题" class="headerlink" title="单源最短路径问题"></a>单源最短路径问题</h3><h4 id="地杰斯特拉方法"><a href="#地杰斯特拉方法" class="headerlink" title="地杰斯特拉方法"></a>地杰斯特拉方法</h4><p><img src= "/img/loading.gif" data-lazy-src="%E5%9C%B0%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%E5%87%86%E5%A4%87.png"></p><p>地杰斯特拉算法不适用于含有负权值的边</p><h4 id="Floyd方法"><a href="#Floyd方法" class="headerlink" title="Floyd方法"></a>Floyd方法</h4><h3 id="B树vsB-树"><a href="#B树vsB-树" class="headerlink" title="B树vsB+树"></a>B树vsB+树</h3><p><img src= "/img/loading.gif" data-lazy-src="B%E6%A0%91vsB+%E6%A0%91.png"></p><h3 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h3><h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>一个把查找表中的关键字映射成该关键字对应的地址的函数。</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h4 id="求next数组："><a href="#求next数组：" class="headerlink" title="求next数组："></a>求next数组：</h4><p><img src= "/img/loading.gif" data-lazy-src="KMP%E6%B1%82next%E6%95%B0%E7%BB%84.png"></p><h4 id="KMP算法-1"><a href="#KMP算法-1" class="headerlink" title="KMP算法"></a>KMP算法</h4><p><img src= "/img/loading.gif" data-lazy-src="KMP%E7%AE%97%E6%B3%95.png"></p><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ol><li><p>直接插入排序</p><p>最好情况下复杂度为$O(n)$，最坏和平均情况下复杂度为$O(n^2)$,空间复杂度为$O(1)$，稳定。适合链表。</p></li><li><p>折半插入排序</p><p>$O(n^2)$,稳定，只适用于顺序存储</p></li><li><p>希尔排序（缩小增量排序）</p><p>最坏情况下：$O(n^2)$ 最好情况:$O(n^{1.3})$</p><p>不稳定。顺序存储。 辅助空间：$O(1)$</p></li></ol><h4 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h4><ol><li><p>冒泡排序</p><p>基本思想：</p><p>假设待排序表长为n，从后往前（从前往后）两两比较相邻元素的值，若为逆序（即$A[i-1]&gt;A[i]$），则交换他们直到序列比较结束。</p><p>最好：$O(n)$</p><p>最坏和平均：$O(n^2)$</p><p>空间复杂度：$O(1)$</p><p>稳定，顺序存储和链式存储</p></li><li><p>快速排序</p><p>选取基准。 </p><p>一次划分会将一个元素pivot放置到它最终的位置上。</p><p>不稳定。</p><p>$O(high-low+1)$</p><p><img src= "/img/loading.gif" data-lazy-src="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png"></p><p>最好、平均空间复杂度$O(log_2n)$</p><p>最好、平均空间复杂度$O(nlog_2n)$</p><p>初始基本有序或逆序：</p><p>最坏情况空间复杂度$O(n)$</p><p>最坏时间复杂度$O(n^2)$</p></li></ol><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ol><li><p>直接选择排序</p><p>一趟排序会将一个元素放置在最终的位置上。</p><p><img src= "/img/loading.gif" data-lazy-src="%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png"></p><p>时间复杂度与初始序列无关：$O(n^2)$</p><p>空间$O(1)$</p><p>顺序存储和链式存储</p></li><li><p>堆排序</p><p>大根堆和小根堆</p><p><img src= "/img/loading.gif" data-lazy-src="%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.png"></p><p>时间复杂度：$O(nlog_2n)$</p><p>空间复杂度：$O(1)$</p><p>不稳定，顺序存储（链式存储）</p></li></ol><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ol><li><p>二路归并排序</p><p>时间复杂度：$O(nlog_2n)$  稳定 顺序存储和链式存储</p><p>空间复杂度：$O(n)$</p></li></ol><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>​    <strong>不基于比较，借助“分配”和“收集”两种操作堆单逻辑关键字进行排序，分为最高位优先（MSD）和最低位优先(LSD)</strong></p><p><img src= "/img/loading.gif" data-lazy-src="%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png"></p><p>时间复杂度：$O(d(n+r))$</p><p>空间复杂度：$O(r)$</p><p>稳定，不基于比较</p><h3 id="内部排序算法比较"><a href="#内部排序算法比较" class="headerlink" title="内部排序算法比较"></a>内部排序算法比较</h3><table><thead><tr><th align="center">排序算法</th><th>时空复杂度</th><th>稳定性</th><th>一趟排序的特点</th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="center">直接插入排序</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">折半插入排序</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">希尔排序</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">冒泡排序</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">快排</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">直接选择排序</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">堆排序</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">二路归并排序</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">基数排序</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src= "/img/loading.gif" data-lazy-src="%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83%E5%92%8C%E5%BA%94%E7%94%A8.png"></p><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><p>通常采用<strong>归并排序方法</strong></p><hr><h1 id="Java整理"><a href="#Java整理" class="headerlink" title="Java整理"></a>Java整理</h1><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>Byte:-128,127</p><p>Character：&lt;=127</p><p>Integer:-128,127</p><p>Short:-128,127</p><p>Long:-128,127</p><p>Boolean: true或者false,注意此处忽略大小写，IgnoreCase</p><p>Double:</p><p>Float:</p><p>总结：Byte,Integer,Short,Long的常量池为[-128,127]</p><p>​    Character的常量池为[0,127]</p><p>​    Boolean的常量池为true/false</p><p>​    对于 == 运算符：</p><p>​        如果两侧对象都是数值，则比较数值；</p><p>​        如果两侧都是包装类型，则比较地址值；</p><p>​        如果一个是数值，一个是包装类型，则包装类型自动拆箱</p><pre><code> 对于 + 运算符：</code></pre><p>​        包装类型自动拆箱。</p><h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><h3 id="特殊之处"><a href="#特殊之处" class="headerlink" title="特殊之处"></a>特殊之处</h3><ul><li>直接继承于<code>java.io.Object</code>类，而不是继承于四个流</li><li>文件是从头覆盖的</li></ul><h2 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h2><blockquote><p>&lt;&lt;    &gt;&gt;    &gt;&gt;&gt;    &amp;    |    ^(异或)    ~</p><p><strong>注意：没有无符号左移</strong></p></blockquote><h2 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a><code>StringBuffer</code>和<code>StringBuilder</code></h2><ol><li><p><code>String:</code>jdk1.0 不可变的字符序列<img src= "/img/loading.gif" data-lazy-src="Java/String%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7.png" alt="String不可变性.png"></p></li><li><p><code>StringBuffer:</code></p></li></ol><h3 id="String-StringBuilder和StringBuffer"><a href="#String-StringBuilder和StringBuffer" class="headerlink" title="String,StringBuilder和StringBuffer"></a><code>String</code>,<code>StringBuilder</code>和<code>StringBuffer</code></h3><ol><li><code>String</code>: JDK1.0</li><li><code>StringBuilder</code>:JDK1.5</li><li><code>StringBuffer</code>:JDK1.0 线程安全 效率偏低<ol><li> <code>StringBuffer</code>扩容过程：<code>StringBuffer</code>继承自<code>AbstractStringBuilder</code>,首先检查<code>count</code>+要增加的字符串的长度 与 <code>AbstractStringBuilder</code>中的<code>value.length</code>的大小关系（即<code>AbstractStringBuilder</code>中原有的value数组是否能够放下修改后的长度），这个比较是通过<code>AbstractStringBuilder</code>中的<code>ensureCapacityInternal(int newLength)</code>方法来完成的。</li><li><code>AbstractStringBuilder</code>中的<code>ensureCapacityInternal(int minumCapacity)</code>方法：<ol><li> <em>该方法的功能是：**</em>真正的扩容数组。如果新的<code>Capacity</code>大于原有的长度，则调用<code>newCapacity()</code>方法进行扩容；否则不进行处理。**</li><li> 比较新的长度和原来的<code>value.length</code>，如果大于0，说明原来的长度不够，需要进行扩容。如果不进行扩容，改方法不进行任何操作，直接返回。如果需要扩容，则进入<code>newCapacity(int minumCapacity)</code>方法。</li></ol></li><li><code>AbstractStringBuilder</code>中的<code>newCapacity(int minumCapacity)</code>方法：<ol><li> <em>该方法的功能：</em>真正的进行扩容，进行数组长度的改变。</li><li> 先将原来的$value数组的长度 <em>2+2$,与需要的长度进行比较，<del>如果不够用，则将新的长度设置为需要的长度，并进行返回。如果够用，则长度 * 2 + 2就是新的长度。</del>**($原来底层数组的长度</em>2+2$后，取这个长度与<code>minCapacity</code>中的较大值。)**进行返回。</li><li> 然后调用<code>Arrays.CopyOf()</code>方法，进行复制。</li><li>针对大数组的处理：<ol><li> 如果需要的长度&gt;int上界，直接报<code>OutOfMemoryError</code></li><li> 否则返回<code>AbstractStringBuilder</code>允许的数组最大值和<code>minCapacity</code>中的最大值。</li></ol></li></ol></li></ol></li></ol><h3 id="JDK1-8之前的时间API"><a href="#JDK1-8之前的时间API" class="headerlink" title="JDK1.8之前的时间API"></a><code>JDK1.8</code>之前的时间API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.System.currentTimeMillis()</span><br><span class="line"><span class="comment">//返回当前与1970年1月1日0时0分的时间差 的毫秒数</span></span><br></pre></td></tr></table></figure><ol><li><p><code>java.util.Date</code>类：</p><ol><li>两个构造器的使用（怎么造对象）<ol><li><code>Date()</code></li><li><code>Date(long)</code></li></ol></li><li>两个方法的使用<ol><li><code>toString()</code>：显示当前的年月日时分秒</li><li><code>getTime()</code>：显示时间戳</li></ol></li></ol></li><li><p><code>java.sql.Date</code>类：</p><p>1. </p></li><li><p><code>SimpleDateFormat</code></p><ol><li><p>解析：字符串-&gt;Date</p><p>格式化：Date-&gt;字符串</p></li></ol></li><li><p><code>Calendar</code>类</p><ol><li>方式一：创建子类(GregorianCalendar)的对象</li><li>方式二：调用其静态方法getInstance()</li><li>常用方法：<ol><li>get()</li><li>set()</li><li>add()</li><li>getTime()/setTime()</li></ol></li></ol></li></ol><h3 id="jdk1-8之后的API"><a href="#jdk1-8之后的API" class="headerlink" title="jdk1.8之后的API"></a>jdk1.8之后的API</h3><ol><li><p>LocalTime</p></li><li><p>LocalDate</p></li><li><p>LocalDateTime：相较于其它两个用的多</p><ol><li>now()</li><li>of(int,int,int)</li><li>getXxx()</li><li>with(int)</li><li>plusXxx(long)</li><li>minus()</li></ol></li><li><p>Instant</p><ol><li>时间线上的一个瞬时点。这可能被用来记录应用程序中的时间戳</li><li>Instant常用方法：<img src= "/img/loading.gif" data-lazy-src="Instant%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png"></li></ol></li><li><p><code>java.time.format.DateTimeFormatter</code>:用来格式化或解析时间的、类似 于<code>SimpleDateFormat</code></p><ol><li><p><img src= "/img/loading.gif" data-lazy-src="DateTimeFormatter.png"></p></li><li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dateTimeFormatterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//方式一： 预定义的标准格式。如ISO_LOCAL_DATE,ISO_LOCAL_TIME,ISO_LOCAL_DATE_TIME</span></span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">        <span class="comment">//格式化</span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        java.lang.String format = dateTimeFormatter.format(localDateTime);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(format);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="与传统日期处理的转换"><a href="#与传统日期处理的转换" class="headerlink" title="与传统日期处理的转换"></a>与传统日期处理的转换</h3><p><img src= "/img/loading.gif" data-lazy-src="%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E7%9A%84%E8%BD%AC%E6%8D%A2.png"></p><h3 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h3><p>像String、包装类等实现了Comparable接口，重写了compareTo()方法</p><p>重写compareTo方法的规则：</p><p>小于返回负数，等于返回0，大于返回正整数。</p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ol><li>基本数据类型转换为包装类<br>1. </li></ol><h3 id="访问接口中的方法"><a href="#访问接口中的方法" class="headerlink" title="访问接口中的方法"></a>访问接口中的方法</h3><p><code>CompareA.super.method1();</code></p><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><ol><li><code>jdk5.0</code>之前，自定义枚举类</li><li><code>jdk5.0</code>之后，使用<code>enum</code>关键字</li></ol><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="jdk内置的三个基本注解"><a href="#jdk内置的三个基本注解" class="headerlink" title="jdk内置的三个基本注解"></a><code>jdk</code>内置的三个基本注解</h4><ol><li><p>Override</p></li><li><p>Deprecated</p></li><li><p>SuppressWarnings（”unused”,”rawtypes”）：</p><p>抑制编译器警告</p></li><li><p>如何自定义注解</p><p><img src= "/img/loading.gif" data-lazy-src="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3.png"></p><ul><li>定义新的注解使用<code>@interface</code>关键字</li><li>自定义注解自动继承了<code>java.lang.annotation.Annotation</code>接口</li><li><code>Annotation</code>的成员变量在<code>Annotaion</code>定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型及上述所有类型的数组</li><li>可以在定义Annotation的成员变量时为其指定初始值，指定成员变量的初始值可以使用default关键字</li><li>如果只有一个参数成员，建议使用参数名为value</li><li>如果定义的注解含有配置参数，使用时指定参数值，除非它有默认值。格式是“参数名=参数值”，如果只有一个参数成员，且名称为Value,可以省略“value=”</li><li>没有成员定义的Annotation称为标记；包含成员变量的Annotation称为元数据Annotation</li></ul><p>注意：自定义注解必须配上注解处理流程才有意义</p></li><li><p>JDK5.0提供的四个元注解：</p><p>​    <strong>元注解：</strong> 用于修饰其他的Annotation</p><ol><li><p>Retention</p><p><img src= "/img/loading.gif" data-lazy-src="Retention.png"></p><p>只能用于修饰一个Annotation定义，用于指定该Annotation的生命周期，@Retention包含一个<code>RetentionPolicy</code>类型的成员变量，使用<code>@Retention</code>时必须为该value成员变量指定值：</p><ol><li><code>Retention.SOURCE</code>:在源文件中保留，编译器直接丢掉这种形式的注解</li><li><code>Retention.CLASS</code>:在<code>class</code>文件中有效，当运行<code>Java</code>程序时，JVM不会保留注解，<strong>这是默认值</strong></li><li><code>Retention.RUNTIME</code>:在运行时有效，当运行<code>Java</code>程序时，JVM会保留注释。程序可以通过反射获取该注解</li></ol></li><li><p>Target</p><ol><li>用于修饰<code>Annotation</code>定义，用于指定被修饰的<code>Annotation</code>能用于修饰哪些元素。<code>@Target</code>也包含一个名为<code>value</code>的成员变量</li></ol></li></ol></li></ol><table><thead><tr><th align="center">取值</th><th align="center"><code>ElementType</code></th></tr></thead><tbody><tr><td align="center"><code>TYPE</code></td><td align="center">类，接口，注解，枚举类型</td></tr><tr><td align="center"><code>FIELD</code></td><td align="center">属性</td></tr><tr><td align="center"><code>METHOD</code></td><td align="center">方法</td></tr><tr><td align="center"><code>PARAMETER</code></td><td align="center">参数</td></tr><tr><td align="center"><code>CONSTRUCTOR</code></td><td align="center">构造函数</td></tr><tr><td align="center"><code>LOCAL_VARIABLE</code></td><td align="center">局部变量</td></tr><tr><td align="center"><code>ANNOTATIOM_TYPE</code></td><td align="center">注解</td></tr><tr><td align="center"><code>PACKAGE</code></td><td align="center">包</td></tr><tr><td align="center"><code>TYPE_PARAMETER</code></td><td align="center">类型参数（<strong>从jdk 1.8开始</strong>）</td></tr><tr><td align="center"><code>TYPE_USE</code></td><td align="center">类型使用（<strong>从jdk1.8开始</strong>）</td></tr><tr><td align="center">3. Documented</td><td align="center"></td></tr></tbody></table><pre><code>- 用于指定被该元`Annotation`修饰的`Annotation`类将被`javaodc`工具提取成文档。默认情况下，`javadoc`是不包括注解的。    - 定义为`Documented`的注解必须设置`Retention`值为`RUNTIME`</code></pre><ol start="4"><li>Inherited</li></ol><pre><code>- 被它修饰的注解将具有继承性。如果某个类使用了被`@Inherited`修饰的`Annotation`，则其子类将自动具有该注解。    - 比如：如果把标有`@Inherited`注解的自定义注解标在类级别上，子类则可以继承父类级别的注解    - 实际应用中，使用较少</code></pre><ol start="6"><li><p>JDK8 中注解的新特性</p><ol><li>可重复注解<code>@Repeatable</code><ul><li>可以重复定义多个</li><li>代码如下：</li></ul></li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable(Annotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Annotations&#123;</span><br><span class="line">AnnotationTest[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AnnotationTest(&quot;hi&quot;)</span></span><br><span class="line"><span class="meta">@AnnotationTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="meta">@AnnotationTest(value=&quot;1&quot;)</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   <strong>注意事项：</strong><br>    1. 在本来的注解上声明一个<code>@Repetable()</code><br>    1. 容器类的<code>Target</code>要是本来的<code>Annotation</code>的子集<br>    1. 容器类的生命周期要比本来的长<br>    1. 容器类的value（）成员的类型应该是本来类型的数组</p><ol start="2"><li><p>类型注解</p><p><img src= "/img/loading.gif" data-lazy-src="%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3.png"></p><p>  1. </p></li></ol><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li><code>JDK5.0</code>新增的</li><li>泛型类</li><li>泛型方法</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ul><li>Java反射机制提供的功能<ul><li><img src= "/img/loading.gif" data-lazy-src="Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD.png"></li></ul></li></ul><hr><h1 id="Java集合底层"><a href="#Java集合底层" class="headerlink" title="Java集合底层"></a>Java集合底层</h1><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ol><li><p>在JDK７　和JDK8 中效果不同</p></li><li><p>JDK7：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个长度为</span></span><br><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>JDK8中：</p><ol><li><p>底层的Object[]初始化为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code></p><p>add（）第一次调用时才创建数组</p></li></ol></li></ol><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>双向链表</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>同步</p><h3 id="List的遍历方式："><a href="#List的遍历方式：" class="headerlink" title="List的遍历方式："></a><code>List</code>的遍历方式：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//List遍历的方式</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TraverseTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//方式一：迭代器方式</span></span><br><span class="line">       Iterator iterator = list.iterator();</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">           System.out.println(iterator.next());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//方式二：增强for循环</span></span><br><span class="line">       <span class="keyword">for</span> (Object object:list)&#123;</span><br><span class="line">           System.out.println(object);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//方式三：普通的for循环</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">           System.out.println(list.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">/**</span></span><br><span class="line">     <span class="string">*</span> <span class="string">Set接口的实现类：</span></span><br><span class="line">     <span class="string">*</span> <span class="string">/----Set接口：存储无序的、不可重复的数据</span></span><br><span class="line">     <span class="string">*</span>      <span class="string">/----HashSet:作为Set接口的主要实现类；线程不安全的；可以存储Null值</span></span><br><span class="line">     <span class="string">*</span>          <span class="string">/----LinkedHashSet：HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历</span></span><br><span class="line">     <span class="string">*</span>      <span class="string">/----TreeSet：可以按照添加对象的指定属性，进行排序</span></span><br><span class="line">     <span class="string">*</span></span><br><span class="line">     <span class="string">*</span></span><br><span class="line">     <span class="string">*</span> <span class="string">底层：链表+数组</span></span><br><span class="line">     <span class="string">*</span> <span class="string">要求：向Set中添加的数剧，其所在的类一定要重写hashcode()和equals()方法</span></span><br><span class="line">     <span class="string">*</span>       <span class="string">并且hashcode()和equals()尽可能保持一致性：“相等的对象必须具有相等的散列码”</span></span><br><span class="line">     <span class="string">*</span></span><br><span class="line">     <span class="string">*</span></span><br><span class="line">     <span class="string">*</span> <span class="string">Set接口中没有额外定义的方法（都是Collection接口中的方法）</span></span><br><span class="line">     <span class="string">*</span></span><br><span class="line">     <span class="string">*</span> <span class="string">HashSet添加元素的过程：</span></span><br><span class="line">     <span class="string">*</span> <span class="string">我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，</span></span><br><span class="line">     <span class="string">*</span> <span class="string">此哈希值接着通过某种算法计算出在Hashset底层数组中的存放位置（即为：索引位置），判断</span></span><br><span class="line">     <span class="string">*</span> <span class="string">数组此位置上是否已经有其它元素：</span></span><br><span class="line">     <span class="string">*</span> <span class="string">如果此位置上没有其它元素，则元素a添加成功</span></span><br><span class="line">     <span class="string">*</span> <span class="string">如果此位置上有其它元素b(或以链表形式存在的多个元素)，则比较元素a与元素b的哈希值：</span></span><br><span class="line">     <span class="string">*</span>      <span class="string">如果hash值不同，则元素a添加成功。</span></span><br><span class="line">     <span class="string">*</span>      <span class="string">如果hash什相同，进而要调用元素a所在类的equals()方法：</span></span><br><span class="line">     <span class="string">*</span>          <span class="string">equals()返回true,元素a</span> <span class="string">igdn</span> <span class="string">lk</span> <span class="string">rw</span> <span class="string">mty</span> <span class="string">添加失败</span></span><br><span class="line">     <span class="string">*</span>          <span class="string">equals()返回false,元素添加成功</span></span><br><span class="line">     <span class="string">*</span></span><br><span class="line">     <span class="string">*</span></span><br><span class="line">     <span class="string">*</span>  <span class="string">jdk7:a放到数组中，指向原来的元素</span></span><br><span class="line">     <span class="string">*</span>  <span class="string">jdk8:原来的元素放到数组中，指向元素a</span></span><br><span class="line">     <span class="string">*/</span></span><br><span class="line">    <span class="string">@Test</span></span><br><span class="line">    <span class="string">public</span> <span class="string">void</span> <span class="string">SetTest()&#123;</span></span><br><span class="line"><span class="string">//</span>        <span class="string">Arrays.hashCode()</span></span><br><span class="line">        <span class="string">String</span> <span class="string">a</span> <span class="string">=</span> <span class="string">new</span> <span class="string">String(&quot;a&quot;);</span></span><br><span class="line">        <span class="string">String</span> <span class="string">b</span> <span class="string">=new</span> <span class="string">String(&quot;a&quot;);</span></span><br><span class="line">        <span class="string">System.out.println(a==b);</span></span><br><span class="line">        <span class="string">System.out.println(a.equals(b));</span></span><br><span class="line">        <span class="string">System.out.println(a.hashCode());</span></span><br><span class="line">        <span class="string">System.out.println(b.hashCode());</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*LinkedHashSet：怎为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记</span></span><br><span class="line"><span class="comment">    *  录此数据前一个数据和后一个数据。</span></span><br><span class="line"><span class="comment">    *  目的：对于频繁的遍历操作，其效率高于HashSet</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><h3 id="hashcode-方法的重写"><a href="#hashcode-方法的重写" class="headerlink" title="hashcode()方法的重写"></a>hashcode()方法的重写</h3><p><img src= "/img/loading.gif" data-lazy-src="hashcode31.png"></p><hr><h1 id="Jdk7-新特性"><a href="#Jdk7-新特性" class="headerlink" title="Jdk7 新特性"></a>Jdk7 新特性</h1><ul><li>类型推断</li><li>try语句中资源的自动关闭<ul><li>要求必须在try后面的小括号中进行初始化</li></ul></li></ul><hr><h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><ul><li><p>try-catch操作情况</p><ul><li><p>jdk 8 之前，普通形式</p></li><li><p>jdk 8中，资源的关闭操作：</p><ul><li><blockquote><p>try( ):里面放需要关闭的资源</p><p>要求：执行后必须关闭的资源必须在try子句中初始化，否则编译不通过</p></blockquote></li></ul></li></ul></li></ul><hr><h1 id="Java9-新特性"><a href="#Java9-新特性" class="headerlink" title="Java9 新特性"></a>Java9 新特性</h1><ul><li>钻石操作符可以在匿名实现类中使用</li><li>try操作的升级<ul><li>自动关闭的资源初始化可以放在try()外，此时资源是final的。（不可修改）</li></ul></li><li>String底层存储结构变更<ul><li>byte[]</li></ul></li><li><h2 id="集合工厂方法"><a href="#集合工厂方法" class="headerlink" title="集合工厂方法"></a>集合工厂方法</h2></li><li>InputStream中的transferTo()方法</li></ul><hr><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式常用的七大原则：</p><ol><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转原则</li><li>里氏替换原则</li><li>开闭原则(ocp)</li><li>迪米特法则</li><li>合成复用原则(有些书上没有单独列出来)</li></ol><hr><h1 id="操作系统整理"><a href="#操作系统整理" class="headerlink" title="操作系统整理"></a>操作系统整理</h1><h2 id="页面置换算法："><a href="#页面置换算法：" class="headerlink" title="页面置换算法："></a>页面置换算法：</h2><ol><li><p>OPT（最佳）置换算法</p><p>淘汰的是以后永不使用的页面，或者在最长时间内不被访问的方法。</p><p>目前无法预知进程在内存下的哪个页面是未来最长时间不被访问的，因此该方法目前无法实现。</p></li><li><p>先进先出（FIFO）置换算法</p><p>换出最先进入内存的页面。</p><p><strong>只有该方法会出现Belady异常</strong>，随着分配的物理块数增大，页故障数不减反增。</p></li><li><p>最近最久未使用算法（LRU）</p><p>换出最近最长时间未被访问过的页面淘汰。</p><p>堆栈类算法不会出现Belady异常</p></li><li><p>时钟置换算法（CLOCK）</p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
